[
    {
        "url": "https://en.wikipedia.org/wiki/CUDA",
        "crawl": {
            "loadedUrl": "https://en.wikipedia.org/wiki/CUDA",
            "loadedTime": "2024-11-13T11:44:26.897Z",
            "referrerUrl": "https://en.wikipedia.org/wiki/CUDA",
            "depth": 0,
            "httpStatusCode": 200
        },
        "metadata": {
            "canonicalUrl": "https://en.wikipedia.org/wiki/CUDA",
            "title": "CUDA - Wikipedia",
            "description": null,
            "author": null,
            "keywords": null,
            "languageCode": "en",
            "openGraph": [
                {
                    "property": "og:image",
                    "content": "https://upload.wikimedia.org/wikipedia/en/b/b9/Nvidia_CUDA_Logo.jpg"
                },
                {
                    "property": "og:image:width",
                    "content": "1200"
                },
                {
                    "property": "og:image:height",
                    "content": "727"
                },
                {
                    "property": "og:image",
                    "content": "https://upload.wikimedia.org/wikipedia/en/b/b9/Nvidia_CUDA_Logo.jpg"
                },
                {
                    "property": "og:image:width",
                    "content": "800"
                },
                {
                    "property": "og:image:height",
                    "content": "485"
                },
                {
                    "property": "og:image:width",
                    "content": "640"
                },
                {
                    "property": "og:image:height",
                    "content": "388"
                },
                {
                    "property": "og:title",
                    "content": "CUDA - Wikipedia"
                },
                {
                    "property": "og:type",
                    "content": "website"
                }
            ],
            "jsonLd": [
                {
                    "@context": "https://schema.org",
                    "@type": "Article",
                    "name": "CUDA",
                    "url": "https://en.wikipedia.org/wiki/CUDA",
                    "sameAs": "http://www.wikidata.org/entity/Q477690",
                    "mainEntity": "http://www.wikidata.org/entity/Q477690",
                    "author": {
                        "@type": "Organization",
                        "name": "Contributors to Wikimedia projects"
                    },
                    "publisher": {
                        "@type": "Organization",
                        "name": "Wikimedia Foundation, Inc.",
                        "logo": {
                            "@type": "ImageObject",
                            "url": "https://www.wikimedia.org/static/images/wmf-hor-googpub.png"
                        }
                    },
                    "datePublished": "2006-11-14T13:12:46Z",
                    "dateModified": "2024-11-06T10:39:22Z",
                    "image": "https://upload.wikimedia.org/wikipedia/en/b/b9/Nvidia_CUDA_Logo.jpg",
                    "headline": "parallel computing platform and programming model"
                }
            ],
            "headers": {
                "date": "Tue, 12 Nov 2024 17:57:21 GMT",
                "server": "mw-web.codfw.main-77cffc86c8-9hhgk",
                "x-content-type-options": "nosniff",
                "content-language": "en",
                "accept-ch": "",
                "vary": "Accept-Encoding, Cookie, Authorization",
                "last-modified": "Tue, 12 Nov 2024 17:56:14 GMT",
                "content-type": "text/html; charset=UTF-8",
                "content-encoding": "gzip",
                "age": "64022",
                "x-cache": "cp2039 hit, cp2029 hit/10",
                "x-cache-status": "hit-front",
                "server-timing": "cache;desc=\"hit-front\", host;desc=\"cp2029\"",
                "strict-transport-security": "max-age=106384710; includeSubDomains; preload",
                "report-to": "{ \"group\": \"wm_nel\", \"max_age\": 604800, \"endpoints\": [{ \"url\": \"https://intake-logging.wikimedia.org/v1/events?stream=w3c.reportingapi.network_error&schema_uri=/w3c/reportingapi/network_error/1.0.0\" }] }",
                "nel": "{ \"report_to\": \"wm_nel\", \"max_age\": 604800, \"failure_fraction\": 0.05, \"success_fraction\": 0.0}",
                "set-cookie": "WMF-Last-Access=13-Nov-2024;Path=/;HttpOnly;secure;Expires=Sun, 15 Dec 2024 00:00:00 GMT\nWMF-Last-Access-Global=13-Nov-2024;Path=/;Domain=.wikipedia.org;HttpOnly;secure;Expires=Sun, 15 Dec 2024 00:00:00 GMT\nWMF-DP=47c;Path=/;HttpOnly;secure;Expires=Wed, 13 Nov 2024 00:00:00 GMT\nGeoIP=US:::37.75:-97.82:v4; Path=/; secure; Domain=.wikipedia.org\nNetworkProbeLimit=0.001;Path=/;Secure;SameSite=Lax;Max-Age=3600",
                "x-client-ip": "155.94.166.79",
                "cache-control": "private, s-maxage=0, max-age=0, must-revalidate, no-transform",
                "accept-ranges": "bytes",
                "content-length": "66316",
                "x-firefox-spdy": "h2"
            }
        },
        "screenshotUrl": null,
        "text": "CUDA - Wikipedia\nCUDA\n\t\nDeveloper(s)Nvidia\t\nInitial releaseJune 23, 2007; 17 years ago\t\nStable release\n12.6 / August 2024; 3 months ago\n\t\nOperating systemWindows, Linux\t\nPlatformSupported GPUs\t\nTypeGPGPU\t\nLicenseProprietary\t\nWebsitedeveloper.nvidia.com/cuda-zone\t\nIn computing, CUDA (originally Compute Unified Device Architecture) is a proprietary[1] parallel computing platform and application programming interface (API) that allows software to use certain types of graphics processing units (GPUs) for accelerated general-purpose processing, an approach called general-purpose computing on GPUs (GPGPU). CUDA API and its runtime: The CUDA API is an extension of the C programming language that adds the ability to specify thread-level parallelism in C and also to specify GPU device specific operations (like moving data between the CPU and the GPU).[2] CUDA is a software layer that gives direct access to the GPU's virtual instruction set and parallel computational elements for the execution of compute kernels.[3] In addition to drivers and runtime kernels, the CUDA platform includes compilers, libraries and developer tools to help programmers accelerate their applications. \nCUDA is designed to work with programming languages such as C, C++, Fortran and Python. This accessibility makes it easier for specialists in parallel programming to use GPU resources, in contrast to prior APIs like Direct3D and OpenGL, which require advanced skills in graphics programming.[4] CUDA-powered GPUs also support programming frameworks such as OpenMP, OpenACC and OpenCL.[5][3] \nCUDA was created by Nvidia in 2006.[6] When it was first introduced, the name was an acronym for Compute Unified Device Architecture,[7] but Nvidia later dropped the common use of the acronym and now rarely expands it.[8] \nThe graphics processing unit (GPU), as a specialized computer processor, addresses the demands of real-time high-resolution 3D graphics compute-intensive tasks. By 2012, GPUs had evolved into highly parallel multi-core systems allowing efficient manipulation of large blocks of data. This design is more effective than general-purpose central processing unit (CPUs) for algorithms in situations where processing large blocks of data is done in parallel, such as: \ncryptographic hash functions\nmachine learning\nmolecular dynamics simulations\nphysics engines\nIan Buck, while at Stanford in 2000, created an 8K gaming rig using 32 GeForce cards, then obtained a DARPA grant to perform general purpose parallel programming on GPUs. He then joined Nvidia, where since 2004 he has been overseeing CUDA development. In pushing for CUDA, Jensen Huang aimed for the Nvidia GPUs to become a general hardware for scientific computing. CUDA was released in 2006. Around 2015, the focus of CUDA changed to neural networks.[9] \nThe following table offers a non-exact description for the ontology of CUDA framework. \nThe ontology of CUDA framework \nmemory\n(hardware) memory (code, or variable scoping) computation\n(hardware) computation\n(code syntax) computation\n(code semantics) \nRAM \tnon-CUDA variables \thost \tprogram \tone routine call \t\nVRAM,\nGPU L2 cache \tglobal, const, texture \tdevice \tgrid \tsimultaneous call of the same subroutine on many processors \t\nGPU L1 cache \tlocal, shared \tSM (\"streaming multiprocessor\") \tblock \tindividual subroutine call \t\n\t\twarp = 32 threads \t\tSIMD instructions \t\nGPU L0 cache,\nregister \t\tthread (aka. \"SP\", \"streaming processor\", \"cuda core\", but these names are now deprecated) \t\tanalogous to individual scalar ops within a vector op \t\nProgramming abilities\n[edit]\nExample of CUDA processing flow \nCopy data from main memory to GPU memory\nCPU initiates the GPU compute kernel\nGPU's CUDA cores execute the kernel in parallel\nCopy the resulting data from GPU memory to main memory\nThe CUDA platform is accessible to software developers through CUDA-accelerated libraries, compiler directives such as OpenACC, and extensions to industry-standard programming languages including C, C++, Fortran and Python. C/C++ programmers can use 'CUDA C/C++', compiled to PTX with nvcc, Nvidia's LLVM-based C/C++ compiler, or by clang itself.[10] Fortran programmers can use 'CUDA Fortran', compiled with the PGI CUDA Fortran compiler from The Portland Group.[needs update] Python programmers can use the cuNumeric library to accelerate applications on Nvidia GPUs. \nIn addition to libraries, compiler directives, CUDA C/C++ and CUDA Fortran, the CUDA platform supports other computational interfaces, including the Khronos Group's OpenCL,[11] Microsoft's DirectCompute, OpenGL Compute Shader and C++ AMP.[12] Third party wrappers are also available for Python, Perl, Fortran, Java, Ruby, Lua, Common Lisp, Haskell, R, MATLAB, IDL, Julia, and native support in Mathematica. \nIn the computer game industry, GPUs are used for graphics rendering, and for game physics calculations (physical effects such as debris, smoke, fire, fluids); examples include PhysX and Bullet. CUDA has also been used to accelerate non-graphical applications in computational biology, cryptography and other fields by an order of magnitude or more.[13][14][15][16][17] \nCUDA provides both a low level API (CUDA Driver API, non single-source) and a higher level API (CUDA Runtime API, single-source). The initial CUDA SDK was made public on 15 February 2007, for Microsoft Windows and Linux. Mac OS X support was later added in version 2.0,[18] which supersedes the beta released February 14, 2008.[19] CUDA works with all Nvidia GPUs from the G8x series onwards, including GeForce, Quadro and the Tesla line. CUDA is compatible with most standard operating systems. \nCUDA 8.0 comes with the following libraries (for compilation & runtime, in alphabetical order): \ncuBLAS – CUDA Basic Linear Algebra Subroutines library\nCUDART – CUDA Runtime library\ncuFFT – CUDA Fast Fourier Transform library\ncuRAND – CUDA Random Number Generation library\ncuSOLVER – CUDA based collection of dense and sparse direct solvers\ncuSPARSE – CUDA Sparse Matrix library\nNPP – NVIDIA Performance Primitives library\nnvGRAPH – NVIDIA Graph Analytics library\nNVML – NVIDIA Management Library\nNVRTC – NVIDIA Runtime Compilation library for CUDA C++\nCUDA 8.0 comes with these other software components: \nnView – NVIDIA nView Desktop Management Software\nNVWMI – NVIDIA Enterprise Management Toolkit\nGameWorks PhysX – is a multi-platform game physics engine\nCUDA 9.0–9.2 comes with these other components: \nCUTLASS 1.0 – custom linear algebra algorithms,\nNVIDIA Video Decoder was deprecated in CUDA 9.2; it is now available in NVIDIA Video Codec SDK\nCUDA 10 comes with these other components: \nnvJPEG – Hybrid (CPU and GPU) JPEG processing\nCUDA 11.0–11.8 comes with these other components:[20][21][22][23] \nCUB is new one of more supported C++ libraries\nMIG multi instance GPU support\nnvJPEG2000 – JPEG 2000 encoder and decoder\nCUDA has several advantages over traditional general-purpose computation on GPUs (GPGPU) using graphics APIs: \nScattered reads – code can read from arbitrary addresses in memory.\nUnified virtual memory (CUDA 4.0 and above)\nUnified memory (CUDA 6.0 and above)\nShared memory – CUDA exposes a fast shared memory region that can be shared among threads. This can be used as a user-managed cache, enabling higher bandwidth than is possible using texture lookups.[24]\nFaster downloads and readbacks to and from the GPU\nFull support for integer and bitwise operations, including integer texture lookups\nWhether for the host computer or the GPU device, all CUDA source code is now processed according to C++ syntax rules.[25] This was not always the case. Earlier versions of CUDA were based on C syntax rules.[26] As with the more general case of compiling C code with a C++ compiler, it is therefore possible that old C-style CUDA source code will either fail to compile or will not behave as originally intended.\nInteroperability with rendering languages such as OpenGL is one-way, with OpenGL having access to registered CUDA memory but CUDA not having access to OpenGL memory.\nCopying between host and device memory may incur a performance hit due to system bus bandwidth and latency (this can be partly alleviated with asynchronous memory transfers, handled by the GPU's DMA engine).\nThreads should be running in groups of at least 32 for best performance, with total number of threads numbering in the thousands. Branches in the program code do not affect performance significantly, provided that each of 32 threads takes the same execution path; the SIMD execution model becomes a significant limitation for any inherently divergent task (e.g. traversing a space partitioning data structure during ray tracing).\nNo emulation or fallback functionality is available for modern revisions.\nValid C++ may sometimes be flagged and prevent compilation due to the way the compiler approaches optimization for target GPU device limitations.[citation needed]\nC++ run-time type information (RTTI) and C++-style exception handling are only supported in host code, not in device code.\nIn single-precision on first generation CUDA compute capability 1.x devices, denormal numbers are unsupported and are instead flushed to zero, and the precision of both the division and square root operations are slightly lower than IEEE 754-compliant single precision math. Devices that support compute capability 2.0 and above support denormal numbers, and the division and square root operations are IEEE 754 compliant by default. However, users can obtain the prior faster gaming-grade math of compute capability 1.x devices if desired by setting compiler flags to disable accurate divisions and accurate square roots, and enable flushing denormal numbers to zero.[27]\nUnlike OpenCL, CUDA-enabled GPUs are only available from Nvidia as it is proprietary.[28][1] Attempts to implement CUDA on other GPUs include: \nProject Coriander: Converts CUDA C++11 source to OpenCL 1.2 C. A fork of CUDA-on-CL intended to run TensorFlow.[29][30][31]\nCU2CL: Convert CUDA 3.2 C++ to OpenCL C.[32]\nGPUOpen HIP: A thin abstraction layer on top of CUDA and ROCm intended for AMD and Nvidia GPUs. Has a conversion tool for importing CUDA C++ source. Supports CUDA 4.0 plus C++11 and float16.\nZLUDA is a drop-in replacement for CUDA on AMD GPUs and formerly Intel GPUs with near-native performance.[33] The developer, Andrzej Janik, was separately contracted by both Intel and AMD to develop the software in 2021 and 2022, respectively. However, neither company decided to release it officially due to the lack of a business use case. AMD's contract included a clause that allowed Janik to release his code for AMD independently, allowing him to release the new version that only supports AMD GPUs.[34]\nchipStar can compile and run CUDA/HIP programs on advanced OpenCL 3.0 or Level Zero platforms.[35]\nThis example code in C++ loads a texture from an image into an array on the GPU: \ntexture<float, 2, cudaReadModeElementType> tex;\n\nvoid foo()\n{\ncudaArray* cu_array;\n\n// Allocate array\ncudaChannelFormatDesc description = cudaCreateChannelDesc<float>();\ncudaMallocArray(&cu_array, &description, width, height);\n\n// Copy image data to array\ncudaMemcpyToArray(cu_array, image, width*height*sizeof(float), cudaMemcpyHostToDevice);\n\n// Set texture parameters (default)\ntex.addressMode[0] = cudaAddressModeClamp;\ntex.addressMode[1] = cudaAddressModeClamp;\ntex.filterMode = cudaFilterModePoint;\ntex.normalized = false; // do not normalize coordinates\n\n// Bind the array to the texture\ncudaBindTextureToArray(tex, cu_array);\n\n// Run kernel\ndim3 blockDim(16, 16, 1);\ndim3 gridDim((width + blockDim.x - 1)/ blockDim.x, (height + blockDim.y - 1) / blockDim.y, 1);\nkernel<<< gridDim, blockDim, 0 >>>(d_data, height, width);\n\n// Unbind the array from the texture\ncudaUnbindTexture(tex);\n} //end foo()\n\n__global__ void kernel(float* odata, int height, int width)\n{\nunsigned int x = blockIdx.x*blockDim.x + threadIdx.x;\nunsigned int y = blockIdx.y*blockDim.y + threadIdx.y;\nif (x < width && y < height) {\nfloat c = tex2D(tex, x, y);\nodata[y*width+x] = c;\n}\n}\nBelow is an example given in Python that computes the product of two arrays on the GPU. The unofficial Python language bindings can be obtained from PyCUDA.[36] \nimport pycuda.compiler as comp\nimport pycuda.driver as drv\nimport numpy\nimport pycuda.autoinit\n\nmod = comp.SourceModule(\n\"\"\"\n__global__ void multiply_them(float *dest, float *a, float *b)\n{\nconst int i = threadIdx.x;\ndest[i] = a[i] * b[i];\n}\n\"\"\"\n)\n\nmultiply_them = mod.get_function(\"multiply_them\")\n\na = numpy.random.randn(400).astype(numpy.float32)\nb = numpy.random.randn(400).astype(numpy.float32)\n\ndest = numpy.zeros_like(a)\nmultiply_them(drv.Out(dest), drv.In(a), drv.In(b), block=(400, 1, 1))\n\nprint(dest - a * b)\nAdditional Python bindings to simplify matrix multiplication operations can be found in the program pycublas.[37] \n\nimport numpy\nfrom pycublas import CUBLASMatrix\n\nA = CUBLASMatrix(numpy.mat([[1, 2, 3], [4, 5, 6]], numpy.float32))\nB = CUBLASMatrix(numpy.mat([[2, 3], [4, 5], [6, 7]], numpy.float32))\nC = A * B\nprint(C.np_mat())\nwhile CuPy directly replaces NumPy:[38] \nimport cupy\n\na = cupy.random.randn(400)\nb = cupy.random.randn(400)\n\ndest = cupy.zeros_like(a)\n\nprint(dest - a * b)\nSupported CUDA Compute Capability versions for CUDA SDK version and Microarchitecture (by code name): \nCompute Capability (CUDA SDK support vs. Microarchitecture) \nCUDA SDK\nVersion(s) Tesla Fermi Kepler\n(Early) Kepler\n(Late) Maxwell Pascal Volta Turing Ampere Ada\nLovelace Hopper Blackwell \n1.0[39]\t1.0 – 1.1\t\t\t\t\t\t\t\t\t\t\t\t\n1.1\t1.0 – 1.1+x\t\t\t\t\t\t\t\t\t\t\t\t\n2.0\t1.0 – 1.1+x\t\t\t\t\t\t\t\t\t\t\t\t\n2.1 – 2.3.1[40][41][42][43]\t1.0 – 1.3\t\t\t\t\t\t\t\t\t\t\t\t\n3.0 – 3.1[44][45]\t1.0\t2.0\t\t\t\t\t\t\t\t\t\t\t\n3.2[46]\t1.0\t2.1\t\t\t\t\t\t\t\t\t\t\t\n4.0 – 4.2\t1.0\t2.1\t\t\t\t\t\t\t\t\t\t\t\n5.0 – 5.5\t1.0\t\t\t3.5\t\t\t\t\t\t\t\t\t\n6.0\t1.0\t\t3.2\t3.5\t\t\t\t\t\t\t\t\t\n6.5\t1.1\t\t\t3.7\t5.x\t\t\t\t\t\t\t\t\n7.0 – 7.5\t\t2.0\t\t\t5.x\t\t\t\t\t\t\t\t\n8.0\t\t2.0\t\t\t\t6.x\t\t\t\t\t\t\t\n9.0 – 9.2\t\t\t3.0\t\t\t\t7.0 – 7.2\t\t\t\t\t\t\n10.0 – 10.2\t\t\t3.0\t\t\t\t\t7.5\t\t\t\t\t\n11.0[47]\t\t\t\t3.5\t\t\t\t\t8.0\t\t\t\t\n11.1 – 11.4[48]\t\t\t\t3.5\t\t\t\t\t8.6\t\t\t\t\n11.5 – 11.7.1[49]\t\t\t\t3.5\t\t\t\t\t8.7\t\t\t\t\n11.8[50]\t\t\t\t3.5\t\t\t\t\t\t8.9\t9.0\t\t\n12.0 – 12.5\t\t\t\t\t5.0\t\t\t\t\t\t9.0\t\t\nNote: CUDA SDK 10.2 is the last official release for macOS, as support will not be available for macOS in newer releases. \nCUDA Compute Capability by version with associated GPU semiconductors and GPU card models (separated by their various application areas): \nCompute Capability, GPU semiconductors and Nvidia GPU board products \nCompute\ncapability\n(version) Micro-\narchitecture GPUs GeForce Quadro, NVS Tesla/Datacenter Tegra,\nJetson,\nDRIVE \n1.0 \tTesla \tG80 \tGeForce 8800 Ultra, GeForce 8800 GTX, GeForce 8800 GTS(G80) \tQuadro FX 5600, Quadro FX 4600, Quadro Plex 2100 S4 \tTesla C870, Tesla D870, Tesla S870 \t\t\n1.1 \tG92, G94, G96, G98, G84, G86 \tGeForce GTS 250, GeForce 9800 GX2, GeForce 9800 GTX, GeForce 9800 GT, GeForce 8800 GTS(G92), GeForce 8800 GT, GeForce 9600 GT, GeForce 9500 GT, GeForce 9400 GT, GeForce 8600 GTS, GeForce 8600 GT, GeForce 8500 GT,\nGeForce G110M, GeForce 9300M GS, GeForce 9200M GS, GeForce 9100M G, GeForce 8400M GT, GeForce G105M \tQuadro FX 4700 X2, Quadro FX 3700, Quadro FX 1800, Quadro FX 1700, Quadro FX 580, Quadro FX 570, Quadro FX 470, Quadro FX 380, Quadro FX 370, Quadro FX 370 Low Profile, Quadro NVS 450, Quadro NVS 420, Quadro NVS 290, Quadro NVS 295, Quadro Plex 2100 D4,\nQuadro FX 3800M, Quadro FX 3700M, Quadro FX 3600M, Quadro FX 2800M, Quadro FX 2700M, Quadro FX 1700M, Quadro FX 1600M, Quadro FX 770M, Quadro FX 570M, Quadro FX 370M, Quadro FX 360M, Quadro NVS 320M, Quadro NVS 160M, Quadro NVS 150M, Quadro NVS 140M, Quadro NVS 135M, Quadro NVS 130M, Quadro NVS 450, Quadro NVS 420,[51] Quadro NVS 295 \t\t\t\n1.2 \tGT218, GT216, GT215 \tGeForce GT 340*, GeForce GT 330*, GeForce GT 320*, GeForce 315*, GeForce 310*, GeForce GT 240, GeForce GT 220, GeForce 210,\nGeForce GTS 360M, GeForce GTS 350M, GeForce GT 335M, GeForce GT 330M, GeForce GT 325M, GeForce GT 240M, GeForce G210M, GeForce 310M, GeForce 305M \tQuadro FX 380 Low Profile, Quadro FX 1800M, Quadro FX 880M, Quadro FX 380M,\nNvidia NVS 300, NVS 5100M, NVS 3100M, NVS 2100M, ION \t\t\t\n1.3 \tGT200, GT200b \tGeForce GTX 295, GTX 285, GTX 280, GeForce GTX 275, GeForce GTX 260 \tQuadro FX 5800, Quadro FX 4800, Quadro FX 4800 for Mac, Quadro FX 3800, Quadro CX, Quadro Plex 2200 D2 \tTesla C1060, Tesla S1070, Tesla M1060 \t\t\n2.0 \tFermi \tGF100, GF110 \tGeForce GTX 590, GeForce GTX 580, GeForce GTX 570, GeForce GTX 480, GeForce GTX 470, GeForce GTX 465,\nGeForce GTX 480M \tQuadro 6000, Quadro 5000, Quadro 4000, Quadro 4000 for Mac, Quadro Plex 7000,\nQuadro 5010M, Quadro 5000M \tTesla C2075, Tesla C2050/C2070, Tesla M2050/M2070/M2075/M2090 \t\t\n2.1 \tGF104, GF106 GF108, GF114, GF116, GF117, GF119 \tGeForce GTX 560 Ti, GeForce GTX 550 Ti, GeForce GTX 460, GeForce GTS 450, GeForce GTS 450*, GeForce GT 640 (GDDR3), GeForce GT 630, GeForce GT 620, GeForce GT 610, GeForce GT 520, GeForce GT 440, GeForce GT 440*, GeForce GT 430, GeForce GT 430*, GeForce GT 420*,\nGeForce GTX 675M, GeForce GTX 670M, GeForce GT 635M, GeForce GT 630M, GeForce GT 625M, GeForce GT 720M, GeForce GT 620M, GeForce 710M, GeForce 610M, GeForce 820M, GeForce GTX 580M, GeForce GTX 570M, GeForce GTX 560M, GeForce GT 555M, GeForce GT 550M, GeForce GT 540M, GeForce GT 525M, GeForce GT 520MX, GeForce GT 520M, GeForce GTX 485M, GeForce GTX 470M, GeForce GTX 460M, GeForce GT 445M, GeForce GT 435M, GeForce GT 420M, GeForce GT 415M, GeForce 710M, GeForce 410M \tQuadro 2000, Quadro 2000D, Quadro 600,\nQuadro 4000M, Quadro 3000M, Quadro 2000M, Quadro 1000M,\nNVS 310, NVS 315, NVS 5400M, NVS 5200M, NVS 4200M \t\t\t\n3.0 \tKepler \tGK104, GK106, GK107 \tGeForce GTX 770, GeForce GTX 760, GeForce GT 740, GeForce GTX 690, GeForce GTX 680, GeForce GTX 670, GeForce GTX 660 Ti, GeForce GTX 660, GeForce GTX 650 Ti BOOST, GeForce GTX 650 Ti, GeForce GTX 650,\nGeForce GTX 880M, GeForce GTX 870M, GeForce GTX 780M, GeForce GTX 770M, GeForce GTX 765M, GeForce GTX 760M, GeForce GTX 680MX, GeForce GTX 680M, GeForce GTX 675MX, GeForce GTX 670MX, GeForce GTX 660M, GeForce GT 750M, GeForce GT 650M, GeForce GT 745M, GeForce GT 645M, GeForce GT 740M, GeForce GT 730M, GeForce GT 640M, GeForce GT 640M LE, GeForce GT 735M, GeForce GT 730M \tQuadro K5000, Quadro K4200, Quadro K4000, Quadro K2000, Quadro K2000D, Quadro K600, Quadro K420,\nQuadro K500M, Quadro K510M, Quadro K610M, Quadro K1000M, Quadro K2000M, Quadro K1100M, Quadro K2100M, Quadro K3000M, Quadro K3100M, Quadro K4000M, Quadro K5000M, Quadro K4100M, Quadro K5100M,\nNVS 510, Quadro 410 \tTesla K10, GRID K340, GRID K520, GRID K2 \t\t\n3.2 \tGK20A \t\t\t\tTegra K1,\nJetson TK1 \t\n3.5 \tGK110, GK208 \tGeForce GTX Titan Z, GeForce GTX Titan Black, GeForce GTX Titan, GeForce GTX 780 Ti, GeForce GTX 780, GeForce GT 640 (GDDR5), GeForce GT 630 v2, GeForce GT 730, GeForce GT 720, GeForce GT 710, GeForce GT 740M (64-bit, DDR3), GeForce GT 920M \tQuadro K6000, Quadro K5200 \tTesla K40, Tesla K20x, Tesla K20 \t\t\n3.7 \tGK210 \t\t\tTesla K80 \t\t\n5.0 \tMaxwell \tGM107, GM108 \tGeForce GTX 750 Ti, GeForce GTX 750, GeForce GTX 960M, GeForce GTX 950M, GeForce 940M, GeForce 930M, GeForce GTX 860M, GeForce GTX 850M, GeForce 845M, GeForce 840M, GeForce 830M \tQuadro K1200, Quadro K2200, Quadro K620, Quadro M2000M, Quadro M1000M, Quadro M600M, Quadro K620M, NVS 810 \tTesla M10 \t\t\n5.2 \tGM200, GM204, GM206 \tGeForce GTX Titan X, GeForce GTX 980 Ti, GeForce GTX 980, GeForce GTX 970, GeForce GTX 960, GeForce GTX 950, GeForce GTX 750 SE,\nGeForce GTX 980M, GeForce GTX 970M, GeForce GTX 965M \tQuadro M6000 24GB, Quadro M6000, Quadro M5000, Quadro M4000, Quadro M2000, Quadro M5500,\nQuadro M5000M, Quadro M4000M, Quadro M3000M \tTesla M4, Tesla M40, Tesla M6, Tesla M60 \t\t\n5.3 \tGM20B \t\t\t\tTegra X1,\nJetson TX1,\nJetson Nano,\nDRIVE CX,\nDRIVE PX \t\n6.0 \tPascal \tGP100 \t\tQuadro GP100 \tTesla P100 \t\t\n6.1 \tGP102, GP104, GP106, GP107, GP108 \tNvidia TITAN Xp, Titan X,\nGeForce GTX 1080 Ti, GTX 1080, GTX 1070 Ti, GTX 1070, GTX 1060,\nGTX 1050 Ti, GTX 1050, GT 1030, GT 1010,\nMX350, MX330, MX250, MX230, MX150, MX130, MX110 \tQuadro P6000, Quadro P5000, Quadro P4000, Quadro P2200, Quadro P2000, Quadro P1000, Quadro P400, Quadro P500, Quadro P520, Quadro P600,\nQuadro P5000(Mobile), Quadro P4000(Mobile), Quadro P3000(Mobile) \tTesla P40, Tesla P6, Tesla P4 \t\t\n6.2 \tGP10B[52] \t\t\t\tTegra X2, Jetson TX2, DRIVE PX 2 \t\n7.0 \tVolta \tGV100 \tNVIDIA TITAN V \tQuadro GV100 \tTesla V100, Tesla V100S \t\t\n7.2 \tGV10B[53] \nGV11B[54][55] \n\t\t\t\tTegra Xavier,\nJetson Xavier NX,\nJetson AGX Xavier,\nDRIVE AGX Xavier,\nDRIVE AGX Pegasus,\nClara AGX \t\n7.5 \tTuring \tTU102, TU104, TU106, TU116, TU117 \tNVIDIA TITAN RTX,\nGeForce RTX 2080 Ti, RTX 2080 Super, RTX 2080, RTX 2070 Super, RTX 2070, RTX 2060 Super, RTX 2060 12GB, RTX 2060,\nGeForce GTX 1660 Ti, GTX 1660 Super, GTX 1660, GTX 1650 Super, GTX 1650, MX550, MX450 \tQuadro RTX 8000, Quadro RTX 6000, Quadro RTX 5000, Quadro RTX 4000, T1000, T600, T400\nT1200(mobile), T600(mobile), T500(mobile), Quadro T2000(mobile), Quadro T1000(mobile) \tTesla T4 \t\t\n8.0 \tAmpere \tGA100 \t\t\tA100 80GB, A100 40GB, A30 \t\t\n8.6 \tGA102, GA103, GA104, GA106, GA107 \tGeForce RTX 3090 Ti, RTX 3090, RTX 3080 Ti, RTX 3080 12GB, RTX 3080, RTX 3070 Ti, RTX 3070, RTX 3060 Ti, RTX 3060, RTX 3050, RTX 3050 Ti(mobile), RTX 3050(mobile), RTX 2050(mobile), MX570 \tRTX A6000, RTX A5500, RTX A5000, RTX A4500, RTX A4000, RTX A2000\nRTX A5000(mobile), RTX A4000(mobile), RTX A3000(mobile), RTX A2000(mobile) \tA40, A16, A10, A2 \t\t\n8.7 \tGA10B \t\t\t\tJetson Orin Nano,\nJetson Orin NX,\nJetson AGX Orin,\nDRIVE AGX Orin,\nDRIVE AGX Pegasus OA,\nClara Holoscan \t\n8.9 \tAda Lovelace[56] \tAD102, AD103, AD104, AD106, AD107 \tGeForce RTX 4090, RTX 4080 Super, RTX 4080, RTX 4070 Ti Super, RTX 4070 Ti, RTX 4070 Super, RTX 4070, RTX 4060 Ti, RTX 4060 \tRTX 6000 Ada, RTX 5880 Ada, RTX 5000 Ada, RTX 4500 Ada, RTX 4000 Ada, RTX 4000 SFF \tL40S, L40, L20, L4, L2 \t\t\n9.0 \tHopper \tGH100 \t\t\tH200, H100 \t\t\n10.0 \tBlackwell \tGB100 \t\t\tB200, B100 \t\t\n10.x \tGB202, GB203, GB205, GB206, GB207 \tGeForce RTX 5090, RTX 5080 \t\tB40 \t\t\nCompute\ncapability\n(version) Micro-\narchitecture GPUs GeForce Quadro, NVS Tesla/Datacenter Tegra,\nJetson,\nDRIVE \n'*' – OEM-only products \nVersion features and specifications\n[edit]\n\t\nThis section needs to be updated. The reason given is: Missing CUDA compute capability 10.x (Blackwell). Please help update this article to reflect recent events or newly available information. (March 2024)\n\t\nFeature support (unlisted features are supported for all compute capabilities) Compute capability (version) \n1.0, 1.1 1.2, 1.3 2.x 3.0 3.2 3.5, 3.7, 5.x, 6.x, 7.0, 7.2 7.5 8.x 9.0 \nWarp vote functions (__all(), __any()) \tNo \tYes \t\nWarp vote functions (__ballot()) \tNo \tYes \t\nMemory fence functions (__threadfence_system()) \t\nSynchronization functions (__syncthreads_count(), __syncthreads_and(), __syncthreads_or()) \t\nSurface functions \t\n3D grid of thread blocks \t\nWarp shuffle functions \tNo \tYes \t\nUnified memory programming \t\nFunnel shift \tNo \tYes \t\nDynamic parallelism \tNo \tYes \t\nUniform Datapath[57] \tNo \tYes \t\nHardware-accelerated async-copy \tNo \tYes \t\nHardware-accelerated split arrive/wait barrier \t\nWarp-level support for reduction ops \t\nL2 cache residency management \t\nDPX instructions for accelerated dynamic programming \tNo \tYes \t\nDistributed shared memory \t\nThread block cluster \t\nTensor memory accelerator (TMA) unit \t\nFeature support (unlisted features are supported for all compute capabilities) 1.0,1.1 1.2,1.3 2.x 3.0 3.2 3.5, 3.7, 5.x, 6.x, 7.0, 7.2 7.5 8.x 9.0 \nCompute capability (version) \n[58] \nData type Operation Supported since\nAtomic Operation Supported since\nfor global memory Supported since\nfor shared memory \n8-bit integer\nsigned/unsigned \tloading, storing, conversion \t1.0 \t— \t— \t\n16-bit integer\nsigned/unsigned \tgeneral operations \t1.0 \tatomicCAS() \t3.5 \t\n32-bit integer\nsigned/unsigned \tgeneral operations \t1.0 \tatomic functions \t1.1 \t1.2 \t\n64-bit integer\nsigned/unsigned \tgeneral operations \t1.0 \tatomic functions \t1.2 \t2.0 \t\nany 128-bit trivially copyable type \tgeneral operations \tNo \tatomicExch, atomicCAS \t9.0 \t\n16-bit floating point\nFP16 \taddition, subtraction,\nmultiplication, comparison,\nwarp shuffle functions, conversion \t5.3 \thalf2 atomic addition \t6.0 \t\natomic addition \t7.0 \t\n16-bit floating point\nBF16 \taddition, subtraction,\nmultiplication, comparison,\nwarp shuffle functions, conversion \t8.0 \tatomic addition \t8.0 \t\n32-bit floating point \tgeneral operations \t1.0 \tatomicExch() \t1.1 \t1.2 \t\natomic addition \t2.0 \t\n32-bit floating point float2 and float4 \tgeneral operations \tNo \tatomic addition \t9.0 \t\n64-bit floating point \tgeneral operations \t1.3 \tatomic addition \t6.0 \t\nNote: Any missing lines or empty entries do reflect some lack of information on that exact item.[59] \nFMA per cycle per tensor core[60] Supported since 7.0 7.2 7.5 Workstation 7.5 Desktop 8.0 8.6 Workstation 8.7 8.6 Desktop 8.9 Desktop 8.9 Workstation 9.0 10.0 \nData Type For dense matrices For sparse matrices 1st Gen (8x/SM) \t1st Gen? (8x/SM) \t2nd Gen (8x/SM) \t3rd Gen (4x/SM) \t4th Gen (4x/SM) \t5th Gen (4x/SM) \t\n1-bit values (AND) \t8.0 as\nexperimental \tNo \tNo \t4096 \t2048 \tspeed tbd \t\n1-bit values (XOR) \t7.5–8.9 as\nexperimental \tNo \t1024 \tDeprecated or removed? \t\n4-bit integers \t8.0–8.9 as\nexperimental \t256 \t1024 \t512 \t\n4-bit floating point FP4 (E2M1?) \t10.0 \tNo \t4096 \t\n6-bit floating point FP6 (E3M2 and E2M3?) \t10.0 \tNo \t2048 \t\n8-bit integers \t7.2 \t8.0 \tNo \t128 \t128 \t512 \t256 \t1024 \t2048 \t\n8-bit floating point FP8 (E4M3 and E5M2) with FP16 accumulate \t8.9 \tNo \t256 \t\n8-bit floating point FP8 (E4M3 and E5M2) with FP32 accumulate \t\n16-bit floating point FP16 with FP16 accumulate \t7.0 \t8.0 \t64 \t64 \t64 \t256 \t128 \t512 \t1024 \t\n16-bit floating point FP16 with FP32 accumulate \t32 \t64 \t128 \t\n16-bit floating point BF16 with FP32 accumulate \t7.5[61] \t8.0 \tNo \t\n32-bit (19 bits used) floating point TF32 \tspeed tbd (32?) \t128 \t32 \t64 \t256 \t512 \t\n64-bit floating point \t8.0 \tNo \tNo \t16 \tspeed tbd \t32 \t16 \t\nNote: Any missing lines or empty entries do reflect some lack of information on that exact item.[62][63] [64] [65] [66] [67] \nTensor Core Composition 7.0 7.2, 7.5 8.0, 8.6 8.7 8.9 9.0 \nDot Product Unit Width in FP16 units (in bytes)[68][69][70][71] \t4 (8) \t8 (16) \t4 (8) \t16 (32) \t\nDot Product Units per Tensor Core \t16 \t32 \t\nTensor Cores per SM partition \t2 \t1 \t\nFull throughput (Bytes/cycle)[72] per SM partition[73] \t256 \t512 \t256 \t\t1024 \t\nFP Tensor Cores: Minimum cycles for warp-wide matrix calculation \t8 \t4 \t8 \t\t\t\nFP Tensor Cores: Minimum Matrix Shape for full throughput (Bytes)[74] \t2048 \t\t\t\nINT Tensor Cores: Minimum cycles for warp-wide matrix calculation \tNo \t4 \t\t\t\nINT Tensor Cores: Minimum Matrix Shape for full throughput (Bytes) \tNo \t1024 \t2048 \t1024 \t\t\t\n[75][76][77][78] \nFP64 Tensor Core Composition 8.0 8.6 8.7 8.9 9.0 \nDot Product Unit Width in FP64 units (in bytes) \t4 (32) \ttbd \t\t4 (32) \t\nDot Product Units per Tensor Core \t4 \ttbd \t\t8 \t\nTensor Cores per SM partition \t1 \t\nFull throughput (Bytes/cycle)[79] per SM partition[80] \t128 \ttbd \t\t256 \t\nMinimum cycles for warp-wide matrix calculation \t16 \ttbd \t\t\t\nMinimum Matrix Shape for full throughput (Bytes)[81] \t2048 \t\t\t\nTechnical specification\n[edit]\nTechnical specifications Compute capability (version) \n1.0 1.1 1.2 1.3 2.x 3.0 3.2 3.5 3.7 5.0 5.2 5.3 6.0 6.1 6.2 7.0 7.2 7.5 8.0 8.6 8.7 8.9 9.0 \nMaximum number of resident grids per device\n(concurrent kernel execution, can be lower for specific devices) \t1 \t16 \t4 \t32 \t16 \t128 \t32 \t16 \t128 \t16 \t128 \t\nMaximum dimensionality of grid of thread blocks \t2 \t3 \t\nMaximum x-dimension of a grid of thread blocks \t65535 \t231 − 1 \t\nMaximum y-, or z-dimension of a grid of thread blocks \t65535 \t\nMaximum dimensionality of thread block \t3 \t\nMaximum x- or y-dimension of a block \t512 \t1024 \t\nMaximum z-dimension of a block \t64 \t\nMaximum number of threads per block \t512 \t1024 \t\nWarp size \t32 \t\nMaximum number of resident blocks per multiprocessor \t8 \t16 \t32 \t16 \t32 \t16 \t24 \t32 \t\nMaximum number of resident warps per multiprocessor \t24 \t32 \t48 \t64 \t32 \t64 \t48 \t64 \t\nMaximum number of resident threads per multiprocessor \t768 \t1024 \t1536 \t2048 \t1024 \t2048 \t1536 \t2048 \t\nNumber of 32-bit regular registers per multiprocessor \t8 K \t16 K \t32 K \t64 K \t128 K \t64 K \t\nNumber of 32-bit uniform registers per multiprocessor \tNo \t2 K[82] \n[83] \n\t\t\nMaximum number of 32-bit registers per thread block \t8 K \t16 K \t32 K \t64 K \t32 K \t64 K \t32 K \t64 K \t32 K \t64 K \t\nMaximum number of 32-bit regular registers per thread \t124 \t63 \t255 \t\nMaximum number of 32-bit uniform registers per warp \tNo \t63[84] \n[85] \n\t\t\nAmount of shared memory per multiprocessor\n(out of overall shared memory + L1 cache, where applicable) \t16 KiB \t16 / 48 KiB (of 64 KiB) \t16 / 32 / 48 KiB (of 64 KiB) \t80 / 96 / 112 KiB (of 128 KiB) \t64 KiB \t96 KiB \t64 KiB \t96 KiB \t64 KiB \t0 / 8 / 16 / 32 / 64 / 96 KiB (of 128 KiB) \t32 / 64 KiB (of 96 KiB) \t0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 KiB (of 192 KiB) \t0 / 8 / 16 / 32 / 64 / 100 KiB (of 128 KiB) \t0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 KiB (of 192 KiB) \t0 / 8 / 16 / 32 / 64 / 100 KiB (of 128 KiB) \t0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 / 196 / 228 KiB (of 256 KiB) \t\nMaximum amount of shared memory per thread block \t16 KiB \t48 KiB \t96 KiB \t48 KiB \t64 KiB \t163 KiB \t99 KiB \t163 KiB \t99 KiB \t227 KiB \t\nNumber of shared memory banks \t16 \t32 \t\nAmount of local memory per thread \t16 KiB \t512 KiB \t\nConstant memory size accessible by CUDA C/C++\n(1 bank, PTX can access 11 banks, SASS can access 18 banks) \t64 KiB \t\nCache working set per multiprocessor for constant memory \t8 KiB \t4 KiB \t8 KiB \t\nCache working set per multiprocessor for texture memory \t16 KiB per TPC \t24 KiB per TPC \t12 KiB \t12 – 48 KiB[86] \t24 KiB \t48 KiB \t32 KiB[87] \t24 KiB \t48 KiB \t24 KiB \t32 – 128 KiB \t32 – 64 KiB \t28 – 192 KiB \t28 – 128 KiB \t28 – 192 KiB \t28 – 128 KiB \t28 – 256 KiB \t\nMaximum width for 1D texture reference bound to a CUDA \narray \t8192 \t65536 \t131072 \t\nMaximum width for 1D texture reference bound to linear \nmemory \t227 \t228 \t227 \t228 \t227 \t228 \t\nMaximum width and number of layers for a 1D layered \ntexture reference \t8192 × 512 \t16384 × 2048 \t32768 x 2048 \t\nMaximum width and height for 2D texture reference bound \nto a CUDA array \t65536 × 32768 \t65536 × 65535 \t131072 x 65536 \t\nMaximum width and height for 2D texture reference bound \nto a linear memory \t65000 x 65000 \t65536 x 65536 \t131072 x 65000 \t\nMaximum width and height for 2D texture reference bound \nto a CUDA array supporting texture gather \t— \t16384 x 16384 \t32768 x 32768 \t\nMaximum width, height, and number of layers for a 2D \nlayered texture reference \t8192 × 8192 × 512 \t16384 × 16384 × 2048 \t32768 x 32768 x 2048 \t\nMaximum width, height and depth for a 3D texture \nreference bound to linear memory or a CUDA array \t20483 \t40963 \t163843 \t\nMaximum width (and height) for a cubemap texture reference \t— \t16384 \t32768 \t\nMaximum width (and height) and number of layers \nfor a cubemap layered texture reference \t— \t16384 × 2046 \t32768 × 2046 \t\nMaximum number of textures that can be bound to a \nkernel \t128 \t256 \t\nMaximum width for a 1D surface reference bound to a \nCUDA array \tNot\nsupported \t65536 \t16384 \t32768 \t\nMaximum width and number of layers for a 1D layered \nsurface reference \t65536 × 2048 \t16384 × 2048 \t32768 × 2048 \t\nMaximum width and height for a 2D surface reference \nbound to a CUDA array \t65536 × 32768 \t16384 × 65536 \t131072 × 65536 \t\nMaximum width, height, and number of layers for a 2D \nlayered surface reference \t65536 × 32768 × 2048 \t16384 × 16384 × 2048 \t32768 × 32768 × 2048 \t\nMaximum width, height, and depth for a 3D surface \nreference bound to a CUDA array \t65536 × 32768 × 2048 \t4096 × 4096 × 4096 \t16384 × 16384 × 16384 \t\nMaximum width (and height) for a cubemap surface reference bound to a CUDA array \t32768 \t16384 \t32768 \t\nMaximum width and number of layers for a cubemap \nlayered surface reference \t32768 × 2046 \t16384 × 2046 \t32768 × 2046 \t\nMaximum number of surfaces that can be bound to a \nkernel \t8 \t16 \t32 \t\nMaximum number of instructions per kernel \t2 million \t512 million \t\nMaximum number of Thread Blocks per Thread Block Cluster[88] \tNo \t16 \t\nTechnical specifications 1.0 1.1 1.2 1.3 2.x 3.0 3.2 3.5 3.7 5.0 5.2 5.3 6.0 6.1 6.2 7.0 7.2 7.5 8.0 8.6 8.7 8.9 9.0 \nCompute capability (version) \n[89]\n[90] \nMultiprocessor architecture\n[edit]\nArchitecture specifications Compute capability (version) \n1.0 1.1 1.2 1.3 2.0 2.1 3.0 3.2 3.5 3.7 5.0 5.2 5.3 6.0 6.1 6.2 7.0 7.2 7.5 8.0 8.6 8.7 8.9 9.0 \nNumber of ALU lanes for INT32 arithmetic operations \t8 \t32 \t48 \t192[91] \t128 \t128 \t64 \t128 \t128 \t64 \t64 \t64 \t\nNumber of ALU lanes for any INT32 or FP32 arithmetic operation \t— \t— \t\nNumber of ALU lanes for FP32 arithmetic operations \t64 \t64 \t128 \t128 \t\nNumber of ALU lanes for FP16x2 arithmetic operations \tNo \t1 \t128[92] \t128[93] \t64[94] \t\nNumber of ALU lanes for FP64 arithmetic operations \tNo \t1 \t16 by FP32[95] \t4 by FP32[96] \t8 \t8 / 64[97] \t64 \t4[98] \t32 \t4 \t32 \t2 \t32 \t2 \t2? \t2 \t64 \t\nNumber of Load/Store Units \t4 per 2 SM \t8 per 2 SM \t8 per 2 SM / 3 SM[97] \t8 per 3 SM \t16 \t32 \t16 \t32 \t16 \t32 \t\nNumber of special function units for single-precision floating-point transcendental functions \t2[99] \t4 \t8 \t32 \t16 \t32 \t16 \t\nNumber of texture mapping units (TMU) \t4 per 2 SM \t8 per 2 SM \t8 per 2 / 3SM[97] \t8 per 3 SM \t4 \t4 / 8[97] \t16 \t8 \t16 \t8 \t4 \t\nNumber of ALU lanes for uniform INT32 arithmetic operations \tNo \t2[100] \t\t\nNumber of tensor cores \tNo \t8 (1st gen.)[101] \t0 / 8[97] (2nd gen.) \t4 (3rd gen.) \t4 (4th gen.) \t\nNumber of raytracing cores \tNo \t0 / 1[97] (1st gen.) \tNo \t1 (2nd gen.) \tNo \t1 (3rd gen.) \tNo \t\nNumber of SM Partitions = Processing Blocks[102] \t1 \t4 \t2 \t4 \t\nNumber of warp schedulers per SM partition \t1 \t2 \t4 \t1 \t\nMax number of new instructions issued each cycle by a single scheduler[103] \t2[104] \t1 \t2[105] \t2 \t1 \t\nSize of unified memory for data cache and shared memory \t16 KiB[106] \t16 KiB[106] \t64 KiB \t128 KiB \t64 KiB SM + 24 KiB L1 (separate)[107] \t96 KiB SM + 24 KiB L1 (separate)[107] \t64 KiB SM + 24 KiB L1 (separate)[107] \t64 KiB SM + 24 KiB L1 (separate)[107] \t96 KiB SM + 24 KiB L1 (separate)[107] \t64 KiB SM + 24 KiB L1 (separate)[107] \t128 KiB \t96 KiB[108] \t192 KiB \t128 KiB \t192 KiB \t128 KiB \t256 KiB \t\nSize of L3 instruction cache per GPU \t\t32 KiB[109] \t\tuse L2 Data Cache \t\nSize of L2 instruction cache per Texture Processor Cluster (TPC) \t\t8 KiB \t\t\nSize of L1.5 instruction cache per SM[110] \t\t4 KiB \t\t\t32 KiB \t\t32 KiB \t48 KiB[111] \t128 KiB \t32 KiB \t\t128 KiB \t\t~46 KiB[112] \t128 KiB[113] \t\t\nSize of L1 instruction cache per SM \t\t\t8 KiB \t\t8 KiB \t\t\nSize of L0 instruction cache per SM partition \tonly 1 partition per SM \tNo \t12 KiB \t\t16 KiB?[114] \t32 KiB \t\t\nInstruction Width[115] \t32 bits instructions and 64 bits instructions[116] \t64 bits instructions + 64 bits control logic every 7 instructions \t64 bits instructions + 64 bits control logic every 3 instructions \t128 bits combined instruction and control logic \t\nMemory Bus Width per Memory Partition in bits \t64 ((G)DDR) \t32 ((G)DDR) \t512 (HBM) \t32 ((G)DDR) \t512 (HBM) \t32 ((G)DDR) \t512 (HBM) \t32 ((G)DDR) \t512 (HBM) \t\nL2 Cache per Memory Partition \t16 KiB[117] \t32 KiB[117] \t128 KiB \t256 KiB \t1 MiB \t512 KiB \t128 KiB \t512 KiB \t256 KiB \t128 KiB \t768 KiB \t64 KiB \t512 KiB \t4 MiB \t512 KiB \t8 MiB[118] \t5 MiB \t\nNumber of Render Output Units (ROP) per memory partition (or per GPC in later models) \t4 \t8 \t4 \t8 \t16 \t8 \t12 \t8 \t4 \t16 \t2 \t8 \t16 \t16 per GPC \t3 per GPC \t16 per GPC \t\nArchitecture specifications 1.0 1.1 1.2 1.3 2.0 2.1 3.0 3.2 3.5 3.7 5.0 5.2 5.3 6.0 6.1 6.2 7.0 7.2 7.5 8.0 8.6 8.7 8.9 9.0 \nCompute capability (version) \n[119] \nFor more information read the Nvidia CUDA programming guide.[120] \nCurrent and future usages of CUDA architecture\n[edit]\nAccelerated rendering of 3D graphics\nAccelerated interconversion of video file formats\nAccelerated encryption, decryption and compression\nBioinformatics, e.g. NGS DNA sequencing BarraCUDA[121]\nDistributed calculations, such as predicting the native conformation of proteins\nMedical analysis simulations, for example virtual reality based on CT and MRI scan images\nPhysical simulations,[122] in particular in fluid dynamics\nNeural network training in machine learning problems\nLarge Language Model inference\nFace recognition\nVolunteer computing projects, such as SETI@home and other projects using BOINC software\nMolecular dynamics\nMining cryptocurrencies\nStructure from motion (SfM) software\nComparison with competitors\n[edit]\nCUDA competes with other GPU computing stacks: Intel OneAPI and AMD ROCm. \nWhereas Nvidia's CUDA is closed-source, Intel's OneAPI and AMD's ROCm are open source. \noneAPI is an initiative based in open standards, created to support software development for multiple hardware architectures.[123] The oneAPI libraries must implement open specifications that are discussed publicly by the Special Interest Groups, offering the possibility for any developer or organization to implement their own versions of oneAPI libraries.[124][125] \nOriginally made by Intel, other hardware adopters include Fujitsu and Huawei. \nUnified Acceleration Foundation (UXL)\n[edit]\nUnified Acceleration Foundation (UXL) is a new technology consortium working on the continuation of the OneAPI initiative, with the goal to create a new open standard accelerator software ecosystem, related open standards and specification projects through Working Groups and Special Interest Groups (SIGs). The goal is to offer open alternatives to Nvidia's CUDA. The main companies behind it are Intel, Google, ARM, Qualcomm, Samsung, Imagination, and VMware.[126] \nMain article: ROCm\nROCm[127] is an open source software stack for graphics processing unit (GPU) programming from Advanced Micro Devices (AMD). \nSYCL – an open standard from Khronos Group for programming a variety of platforms, including GPUs, with single-source modern C++, similar to higher-level CUDA Runtime API (single-source)\nBrookGPU – the Stanford University graphics group's compiler\nArray programming\nParallel computing\nStream processing\nrCUDA – an API for computing on remote computers\nMolecular modeling on GPUs\nVulkan – low-level, high-performance 3D graphics and computing API\nOptiX – ray tracing API by NVIDIA\nCUDA binary (cubin) – a type of fat binary\nNumerical Library Collection – by NEC for their vector processor\n^ Jump up to: a b Shah, Agam. \"Nvidia not totally against third parties making CUDA chips\". www.theregister.com. Retrieved 2024-04-25. \n^ Nvidia. \"What is CUDA?\". Nvidia. Retrieved 21 March 2024. \n^ Jump up to: a b Abi-Chahla, Fedy (June 18, 2008). \"Nvidia's CUDA: The End of the CPU?\". Tom's Hardware. Retrieved May 17, 2015. \n^ Zunitch, Peter (2018-01-24). \"CUDA vs. OpenCL vs. OpenGL\". Videomaker. Retrieved 2018-09-16. \n^ \"OpenCL\". NVIDIA Developer. 2013-04-24. Retrieved 2019-11-04. \n^ \"Nvidia CUDA Home Page\". 18 July 2017. \n^ Shimpi, Anand Lal; Wilson, Derek (November 8, 2006). \"Nvidia's GeForce 8800 (G80): GPUs Re-architected for DirectX 10\". AnandTech. Retrieved May 16, 2015. \n^ \"Introduction — nsight-visual-studio-edition 12.6 documentation\". docs.nvidia.com. Retrieved 2024-10-10. \n^ Witt, Stephen (2023-11-27). \"How Jensen Huang's Nvidia Is Powering the A.I. Revolution\". The New Yorker. ISSN 0028-792X. Retrieved 2023-12-10. \n^ \"CUDA LLVM Compiler\". 7 May 2012. \n^ First OpenCL demo on a GPU on YouTube \n^ DirectCompute Ocean Demo Running on Nvidia CUDA-enabled GPU on YouTube \n^ Vasiliadis, Giorgos; Antonatos, Spiros; Polychronakis, Michalis; Markatos, Evangelos P.; Ioannidis, Sotiris (September 2008). \"Gnort: High Performance Network Intrusion Detection Using Graphics Processors\" (PDF). Recent Advances in Intrusion Detection. Lecture Notes in Computer Science. Vol. 5230. pp. 116–134. doi:10.1007/978-3-540-87403-4_7. ISBN 978-3-540-87402-7. \n^ Schatz, Michael C.; Trapnell, Cole; Delcher, Arthur L.; Varshney, Amitabh (2007). \"High-throughput sequence alignment using Graphics Processing Units\". BMC Bioinformatics. 8: 474. doi:10.1186/1471-2105-8-474. PMC 2222658. PMID 18070356. \n^ Manavski, Svetlin A.; Giorgio, Valle (2008). \"CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment\". BMC Bioinformatics. 10 (Suppl 2): S10. doi:10.1186/1471-2105-9-S2-S10. PMC 2323659. PMID 18387198. \n^ \"Pyrit – Google Code\". \n^ \"Use your Nvidia GPU for scientific computing\". BOINC. 2008-12-18. Archived from the original on 2008-12-28. Retrieved 2017-08-08. \n^ \"Nvidia CUDA Software Development Kit (CUDA SDK) – Release Notes Version 2.0 for MAC OS X\". Archived from the original on 2009-01-06. \n^ \"CUDA 1.1 – Now on Mac OS X\". February 14, 2008. Archived from the original on November 22, 2008. \n^ \"CUDA 11 Features Revealed\". 14 May 2020. \n^ \"CUDA Toolkit 11.1 Introduces Support for GeForce RTX 30 Series and Quadro RTX Series GPUs\". 23 September 2020. \n^ \"Enhancing Memory Allocation with New NVIDIA CUDA 11.2 Features\". 16 December 2020. \n^ \"Exploring the New Features of CUDA 11.3\". 16 April 2021. \n^ Silberstein, Mark; Schuster, Assaf; Geiger, Dan; Patney, Anjul; Owens, John D. (2008). \"Efficient computation of sum-products on GPUs through software-managed cache\" (PDF). Proceedings of the 22nd annual international conference on Supercomputing – ICS '08 (PDF). Proceedings of the 22nd annual international conference on Supercomputing – ICS '08. pp. 309–318. doi:10.1145/1375527.1375572. ISBN 978-1-60558-158-3. \n^ \"CUDA C Programming Guide v8.0\" (PDF). nVidia Developer Zone. January 2017. p. 19. Retrieved 22 March 2017. \n^ \"NVCC forces c++ compilation of .cu files\". 29 November 2011. \n^ Whitehead, Nathan; Fit-Florea, Alex. \"Precision & Performance: Floating Point and IEEE 754 Compliance for Nvidia GPUs\" (PDF). Nvidia. Retrieved November 18, 2014. \n^ \"CUDA-Enabled Products\". CUDA Zone. Nvidia Corporation. Retrieved 2008-11-03. \n^ \"Coriander Project: Compile CUDA Codes To OpenCL, Run Everywhere\". Phoronix. \n^ Perkins, Hugh (2017). \"cuda-on-cl\" (PDF). IWOCL. Retrieved August 8, 2017. \n^ \"hughperkins/coriander: Build NVIDIA® CUDA™ code for OpenCL™ 1.2 devices\". GitHub. May 6, 2019. \n^ \"CU2CL Documentation\". chrec.cs.vt.edu. \n^ \"GitHub – vosen/ZLUDA\". GitHub. \n^ Larabel, Michael (2024-02-12), \"AMD Quietly Funded A Drop-In CUDA Implementation Built On ROCm: It's Now Open-Source\", Phoronix, retrieved 2024-02-12 \n^ \"GitHub – chip-spv/chipStar\". GitHub. \n^ \"PyCUDA\". \n^ \"pycublas\". Archived from the original on 2009-04-20. Retrieved 2017-08-08. \n^ \"CuPy\". Retrieved 2020-01-08. \n^ \"NVIDIA CUDA Programming Guide. Version 1.0\" (PDF). June 23, 2007. \n^ \"NVIDIA CUDA Programming Guide. Version 2.1\" (PDF). December 8, 2008. \n^ \"NVIDIA CUDA Programming Guide. Version 2.2\" (PDF). April 2, 2009. \n^ \"NVIDIA CUDA Programming Guide. Version 2.2.1\" (PDF). May 26, 2009. \n^ \"NVIDIA CUDA Programming Guide. Version 2.3.1\" (PDF). August 26, 2009. \n^ \"NVIDIA CUDA Programming Guide. Version 3.0\" (PDF). February 20, 2010. \n^ \"NVIDIA CUDA C Programming Guide. Version 3.1.1\" (PDF). July 21, 2010. \n^ \"NVIDIA CUDA C Programming Guide. Version 3.2\" (PDF). November 9, 2010. \n^ \"CUDA 11.0 Release Notes\". NVIDIA Developer. \n^ \"CUDA 11.1 Release Notes\". NVIDIA Developer. \n^ \"CUDA 11.5 Release Notes\". NVIDIA Developer. \n^ \"CUDA 11.8 Release Notes\". NVIDIA Developer. \n^ \"NVIDIA Quadro NVS 420 Specs\". TechPowerUp GPU Database. 25 August 2023. \n^ Larabel, Michael (March 29, 2017). \"NVIDIA Rolls Out Tegra X2 GPU Support In Nouveau\". Phoronix. Retrieved August 8, 2017. \n^ Nvidia Xavier Specs on TechPowerUp (preliminary) \n^ \"Welcome — Jetson LinuxDeveloper Guide 34.1 documentation\". \n^ \"NVIDIA Bringing up Open-Source Volta GPU Support for Their Xavier SoC\". \n^ \"NVIDIA Ada Lovelace Architecture\". \n^ Dissecting the Turing GPU Architecture through Microbenchmarking \n^ \"H.1. Features and Technical Specifications – Table 13. Feature Support per Compute Capability\". docs.nvidia.com. Retrieved 2020-09-23. \n^ \"CUDA C++ Programming Guide\". \n^ Fused-Multiply-Add, actually executed, Dense Matrix \n^ as SASS since 7.5, as PTX since 8.0 \n^ \"Technical brief. NVIDIA Jetson AGX Orin Series\" (PDF). nvidia.com. Retrieved 5 September 2023. \n^ \"NVIDIA Ampere GA102 GPU Architecture\" (PDF). nvidia.com. Retrieved 5 September 2023. \n^ Luo, Weile; Fan, Ruibo; Li, Zeyu; Du, Dayou; Wang, Qiang; Chu, Xiaowen (2024). \"Benchmarking and Dissecting the Nvidia Hopper GPU Architecture\". arXiv:2402.13499v1 [cs.AR]. \n^ \"Datasheet NVIDIA A40\" (PDF). nvidia.com. Retrieved 27 April 2024. \n^ \"NVIDIA AMPERE GA102 GPU ARCHITECTURE\" (PDF). 27 April 2024. \n^ \"Datasheet NVIDIA L40\" (PDF). 27 April 2024. \n^ In the Whitepapers the Tensor Core cube diagrams represent the Dot Product Unit Width into the height (4 FP16 for Volta and Turing, 8 FP16 for A100, 4 FP16 for GA102, 16 FP16 for GH100). The other two dimensions represent the number of Dot Product Units (4x4 = 16 for Volta and Turing, 8x4 = 32 for Ampere and Hopper). The resulting gray blocks are the FP16 FMA operations per cycle. Pascal without Tensor core is only shown for speed comparison as is Volta V100 with non-FP16 datatypes. \n^ \"NVIDIA Turing Architecture Whitepaper\" (PDF). nvidia.com. Retrieved 5 September 2023. \n^ \"NVIDIA Tensor Core GPU\" (PDF). nvidia.com. Retrieved 5 September 2023. \n^ \"NVIDIA Hopper Architecture In-Depth\". 22 March 2022. \n^ shape x converted operand size, e.g. 2 tensor cores x 4x4x4xFP16/cycle = 256 Bytes/cycle \n^ = product first 3 table rows \n^ = product of previous 2 table rows; shape: e.g. 8x8x4xFP16 = 512 Bytes \n^ Sun, Wei; Li, Ang; Geng, Tong; Stuijk, Sander; Corporaal, Henk (2023). \"Dissecting Tensor Cores via Microbenchmarks: Latency, Throughput and Numeric Behaviors\". IEEE Transactions on Parallel and Distributed Systems. 34 (1): 246–261. arXiv:2206.02874. doi:10.1109/tpds.2022.3217824. S2CID 249431357. \n^ \"Parallel Thread Execution ISA Version 7.7\". \n^ Raihan, Md Aamir; Goli, Negar; Aamodt, Tor (2018). \"Modeling Deep Learning Accelerator Enabled GPUs\". arXiv:1811.08309 [cs.MS]. \n^ \"NVIDIA Ada Lovelace Architecture\". \n^ shape x converted operand size, e.g. 2 tensor cores x 4x4x4xFP16/cycle = 256 Bytes/cycle \n^ = product first 3 table rows \n^ = product of previous 2 table rows; shape: e.g. 8x8x4xFP16 = 512 Bytes \n^ Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". arXiv:1903.07486 [cs.DC]. \n^ Burgess, John (2019). \"RTX ON – The NVIDIA TURING GPU\". 2019 IEEE Hot Chips 31 Symposium (HCS). pp. 1–27. doi:10.1109/HOTCHIPS.2019.8875651. ISBN 978-1-7281-2089-8. S2CID 204822166. \n^ Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". arXiv:1903.07486 [cs.DC]. \n^ Burgess, John (2019). \"RTX ON – The NVIDIA TURING GPU\". 2019 IEEE Hot Chips 31 Symposium (HCS). pp. 1–27. doi:10.1109/HOTCHIPS.2019.8875651. ISBN 978-1-7281-2089-8. S2CID 204822166. \n^ dependent on device \n^ \"Tegra X1\". 9 January 2015. \n^ NVIDIA H100 Tensor Core GPU Architecture \n^ H.1. Features and Technical Specifications – Table 14. Technical Specifications per Compute Capability \n^ NVIDIA Hopper Architecture In-Depth \n^ can only execute 160 integer instructions according to programming guide \n^ 128 according to [1]. 64 from FP32 + 64 separate units? \n^ 64 by FP32 cores and 64 by flexible FP32/INT cores. \n^ \"CUDA C++ Programming Guide\". \n^ 32 FP32 lanes combine to 16 FP64 lanes. Maybe lower depending on model. \n^ only supported by 16 FP32 lanes, they combine to 4 FP64 lanes \n^ Jump up to: a b c d e f depending on model \n^ Effective speed, probably over FP32 ports. No description of actual FP64 cores. \n^ Can also be used for integer additions and comparisons \n^ 2 clock cycles/instruction for each SM partition Burgess, John (2019). \"RTX ON – The NVIDIA TURING GPU\". 2019 IEEE Hot Chips 31 Symposium (HCS). pp. 1–27. doi:10.1109/HOTCHIPS.2019.8875651. ISBN 978-1-7281-2089-8. S2CID 204822166. \n^ Durant, Luke; Giroux, Olivier; Harris, Mark; Stam, Nick (May 10, 2017). \"Inside Volta: The World's Most Advanced Data Center GPU\". Nvidia developer blog. \n^ The schedulers and dispatchers have dedicated execution units unlike with Fermi and Kepler. \n^ Dispatching can overlap concurrently, if it takes more than one cycle (when there are less execution units than 32/SM Partition) \n^ Can dual issue MAD pipe and SFU pipe \n^ No more than one scheduler can issue 2 instructions at once. The first scheduler is in charge of warps with odd IDs. The second scheduler is in charge of warps with even IDs. \n^ Jump up to: a b shared memory only, no data cache \n^ Jump up to: a b c d e f shared memory separate, but L1 includes texture cache \n^ \"H.6.1. Architecture\". docs.nvidia.com. Retrieved 2019-05-13. \n^ \"Demystifying GPU Microarchitecture through Microbenchmarking\" (PDF). \n^ Jia, Zhe; Maggioni, Marco; Staiger, Benjamin; Scarpazza, Daniele P. (2018). \"Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking\". arXiv:1804.06826 [cs.DC]. \n^ \"Tegra X1\". 9 January 2015. \n^ Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". arXiv:1903.07486 [cs.DC]. \n^ \"Dissecting the Ampere GPU Architecture through Microbenchmarking\". \n^ Note that Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". arXiv:1903.07486 [cs.DC]. disagrees and states 2 KiB L0 instruction cache per SM partition and 16 KiB L1 instruction cache per SM \n^ Jia, Zhe; Maggioni, Marco; Staiger, Benjamin; Scarpazza, Daniele P. (2018). \"Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking\". arXiv:1804.06826 [cs.DC]. \n^ \"asfermi Opcode\". GitHub. \n^ Jump up to: a b for access with texture engine only \n^ 25% disabled on RTX 4090 \n^ \"I.7. Compute Capability 8.x\". docs.nvidia.com. Retrieved 2022-10-12. \n^ \"Appendix F. Features and Technical Specifications\" (PDF). (3.2 MiB), page 148 of 175 (Version 5.0 October 2012). \n^ \"nVidia CUDA Bioinformatics: BarraCUDA\". BioCentric. 2019-07-19. Retrieved 2019-10-15. \n^ \"Part V: Physics Simulation\". NVIDIA Developer. Retrieved 2020-09-11. \n^ \"oneAPI Programming Model\". oneAPI.io. Retrieved 2024-07-27. \n^ \"Specifications | oneAPI\". oneAPI.io. Retrieved 2024-07-27. \n^ \"oneAPI Specification — oneAPI Specification 1.3-rev-1 documentation\". oneapi-spec.uxlfoundation.org. Retrieved 2024-07-27. \n^ \"Exclusive: Behind the plot to break Nvidia's grip on AI by targeting software\". Reuters. Retrieved 2024-04-05. \n^ \"Question: What does ROCm stand for? · Issue #1628 · RadeonOpenCompute/ROCm\". Github.com. Retrieved January 18, 2022. \nBuck, Ian; Foley, Tim; Horn, Daniel; Sugerman, Jeremy; Fatahalian, Kayvon; Houston, Mike; Hanrahan, Pat (2004-08-01). \"Brook for GPUs: stream computing on graphics hardware\". ACM Transactions on Graphics. 23 (3): 777–786. doi:10.1145/1015706.1015800. ISSN 0730-0301.\nNickolls, John; Buck, Ian; Garland, Michael; Skadron, Kevin (2008-03-01). \"Scalable Parallel Programming with CUDA: Is CUDA the parallel programming model that application developers have been waiting for?\". Queue. 6 (2): 40–53. doi:10.1145/1365490.1365500. ISSN 1542-7730.\nOfficial website",
        "markdown": "# CUDA - Wikipedia\n\nCUDA\n\n[![](https://upload.wikimedia.org/wikipedia/en/thumb/b/b9/Nvidia_CUDA_Logo.jpg/220px-Nvidia_CUDA_Logo.jpg)](https://en.wikipedia.org/wiki/File:Nvidia_CUDA_Logo.jpg)\n\n[Developer(s)](https://en.wikipedia.org/wiki/Programmer \"Programmer\")\n\n[Nvidia](https://en.wikipedia.org/wiki/Nvidia \"Nvidia\")\n\nInitial release\n\nJune 23, 2007; 17 years ago\n\n[Stable release](https://en.wikipedia.org/wiki/Software_release_life_cycle \"Software release life cycle\")\n\n12.6 / August 2024; 3 months ago\n\n[Operating system](https://en.wikipedia.org/wiki/Operating_system \"Operating system\")\n\n[Windows](https://en.wikipedia.org/wiki/Windows \"Windows\"), [Linux](https://en.wikipedia.org/wiki/Linux \"Linux\")\n\n[Platform](https://en.wikipedia.org/wiki/Computing_platform \"Computing platform\")\n\n[Supported GPUs](#GPUs_supported)\n\n[Type](https://en.wikipedia.org/wiki/Software_categories#Categorization_approaches \"Software categories\")\n\n[GPGPU](https://en.wikipedia.org/wiki/GPGPU \"GPGPU\")\n\n[License](https://en.wikipedia.org/wiki/Software_license \"Software license\")\n\n[Proprietary](https://en.wikipedia.org/wiki/Proprietary_software \"Proprietary software\")\n\nWebsite\n\n[developer.nvidia.com/cuda-zone](https://developer.nvidia.com/cuda-zone)\n\nIn [computing](https://en.wikipedia.org/wiki/Computing \"Computing\"), **CUDA** (originally **Compute Unified Device Architecture**) is a proprietary[\\[1\\]](#cite_note-:0-1) [parallel computing](https://en.wikipedia.org/wiki/Parallel_computing \"Parallel computing\") platform and [application programming interface](https://en.wikipedia.org/wiki/Application_programming_interface \"Application programming interface\") (API) that allows software to use certain types of [graphics processing units](https://en.wikipedia.org/wiki/Graphics_processing_units \"Graphics processing units\") (GPUs) for accelerated general-purpose processing, an approach called general-purpose computing on GPUs ([GPGPU](https://en.wikipedia.org/wiki/GPGPU \"GPGPU\")). CUDA API and its runtime: The CUDA API is an extension of the [C programming language](https://en.wikipedia.org/wiki/C_programming_language \"C programming language\") that adds the ability to specify thread-level parallelism in C and also to specify GPU device specific operations (like moving data between the CPU and the GPU).[\\[2\\]](#cite_note-2) CUDA is a software layer that gives direct access to the GPU's virtual [instruction set](https://en.wikipedia.org/wiki/Instruction_set \"Instruction set\") and parallel computational elements for the execution of [compute kernels](https://en.wikipedia.org/wiki/Compute_kernel \"Compute kernel\").[\\[3\\]](#cite_note-CUDA_intro_-_TomsHardware-3) In addition to drivers and runtime kernels, the CUDA platform includes compilers, libraries and developer tools to help programmers accelerate their applications.\n\nCUDA is designed to work with programming languages such as [C](https://en.wikipedia.org/wiki/C_\\(programming_language\\) \"C (programming language)\"), [C++](https://en.wikipedia.org/wiki/C%2B%2B \"C++\"), [Fortran](https://en.wikipedia.org/wiki/Fortran \"Fortran\") and [Python](https://en.wikipedia.org/wiki/Python_\\(programming_language\\) \"Python (programming language)\"). This accessibility makes it easier for specialists in parallel programming to use GPU resources, in contrast to prior APIs like [Direct3D](https://en.wikipedia.org/wiki/Direct3D \"Direct3D\") and [OpenGL](https://en.wikipedia.org/wiki/OpenGL \"OpenGL\"), which require advanced skills in graphics programming.[\\[4\\]](#cite_note-4) CUDA-powered GPUs also support programming frameworks such as [OpenMP](https://en.wikipedia.org/wiki/OpenMP \"OpenMP\"), [OpenACC](https://en.wikipedia.org/wiki/OpenACC \"OpenACC\") and [OpenCL](https://en.wikipedia.org/wiki/OpenCL \"OpenCL\").[\\[5\\]](#cite_note-5)[\\[3\\]](#cite_note-CUDA_intro_-_TomsHardware-3)\n\nCUDA was created by [Nvidia](https://en.wikipedia.org/wiki/Nvidia \"Nvidia\") in 2006.[\\[6\\]](#cite_note-6) When it was first introduced, the name was an acronym for Compute Unified Device Architecture,[\\[7\\]](#cite_note-CUDA_intro_-_AnandTech-7) but Nvidia later [dropped](https://en.wikipedia.org/wiki/Orphan_initialism \"Orphan initialism\") the common use of the acronym and now rarely expands it.[\\[8\\]](#cite_note-8)\n\nThe graphics processing unit (GPU), as a specialized computer processor, addresses the demands of [real-time](https://en.wikipedia.org/wiki/Real-time_computer_graphics \"Real-time computer graphics\") high-resolution [3D graphics](https://en.wikipedia.org/wiki/3D_graphics \"3D graphics\") compute-intensive tasks. By 2012, GPUs had evolved into highly parallel [multi-core](https://en.wikipedia.org/wiki/Multi-core \"Multi-core\") systems allowing efficient manipulation of large blocks of data. This design is more effective than general-purpose [central processing unit](https://en.wikipedia.org/wiki/Central_processing_unit \"Central processing unit\") (CPUs) for [algorithms](https://en.wikipedia.org/wiki/Algorithm \"Algorithm\") in situations where processing large blocks of data is done in parallel, such as:\n\n*   [cryptographic hash functions](https://en.wikipedia.org/wiki/Cryptographic_hash_function \"Cryptographic hash function\")\n*   [machine learning](https://en.wikipedia.org/wiki/Machine_learning \"Machine learning\")\n*   [molecular dynamics](https://en.wikipedia.org/wiki/Molecular_dynamics \"Molecular dynamics\") simulations\n*   [physics engines](https://en.wikipedia.org/wiki/Physics_engine \"Physics engine\")\n\nIan Buck, while at Stanford in 2000, created an 8K gaming rig using 32 GeForce cards, then obtained a DARPA grant to perform [general purpose parallel programming on GPUs](https://en.wikipedia.org/wiki/General-purpose_computing_on_graphics_processing_units \"General-purpose computing on graphics processing units\"). He then joined Nvidia, where since 2004 he has been overseeing CUDA development. In pushing for CUDA, Jensen Huang aimed for the Nvidia GPUs to become a general hardware for scientific computing. CUDA was released in 2006. Around 2015, the focus of CUDA changed to neural networks.[\\[9\\]](#cite_note-9)\n\nThe following table offers a non-exact description for the [ontology](https://en.wikipedia.org/wiki/Ontology_\\(information_science\\) \"Ontology (information science)\") of CUDA framework.\n\nThe ontology of CUDA framework\n\nmemory  \n(hardware)\n\nmemory (code, or [variable scoping](https://en.wikipedia.org/wiki/Scope_\\(computer_science\\) \"Scope (computer science)\"))\n\ncomputation  \n(hardware)\n\ncomputation  \n(code syntax)\n\ncomputation  \n(code semantics)\n\n[RAM](https://en.wikipedia.org/wiki/Random-access_memory \"Random-access memory\")\n\nnon-CUDA variables\n\nhost\n\nprogram\n\none [routine call](https://en.wikipedia.org/wiki/Function_\\(computer_programming\\) \"Function (computer programming)\")\n\n[VRAM](https://en.wikipedia.org/wiki/Video_random-access_memory \"Video random-access memory\"),  \nGPU L2 cache\n\nglobal, const, texture\n\ndevice\n\ngrid\n\nsimultaneous call of the same [subroutine](https://en.wikipedia.org/wiki/Subroutine \"Subroutine\") on many processors\n\nGPU L1 cache\n\nlocal, shared\n\nSM (\"streaming multiprocessor\")\n\nblock\n\nindividual subroutine call\n\nwarp = 32 threads\n\n[SIMD instructions](https://en.wikipedia.org/wiki/SIMD_instruction \"SIMD instruction\")\n\nGPU L0 cache,  \nregister\n\nthread (aka. \"SP\", \"streaming processor\", \"cuda core\", but these names are now deprecated)\n\nanalogous to individual scalar ops within a vector op\n\n## Programming abilities\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=3 \"Edit section: Programming abilities\")\\]\n\n[![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/59/CUDA_processing_flow_%28En%29.PNG/300px-CUDA_processing_flow_%28En%29.PNG)](https://en.wikipedia.org/wiki/File:CUDA_processing_flow_\\(En\\).PNG)\n\n**Example of CUDA processing flow**\n\n1.  Copy data from main memory to GPU memory\n2.  CPU initiates the GPU [compute kernel](https://en.wikipedia.org/wiki/Compute_kernel \"Compute kernel\")\n3.  GPU's CUDA cores execute the kernel in parallel\n4.  Copy the resulting data from GPU memory to main memory\n\nThe CUDA platform is accessible to software developers through CUDA-accelerated libraries, [compiler directives](https://en.wikipedia.org/wiki/Directive_\\(programming\\) \"Directive (programming)\") such as [OpenACC](https://en.wikipedia.org/wiki/OpenACC \"OpenACC\"), and extensions to industry-standard programming languages including [C](https://en.wikipedia.org/wiki/C_\\(programming_language\\) \"C (programming language)\"), [C++](https://en.wikipedia.org/wiki/C%2B%2B \"C++\"), [Fortran](https://en.wikipedia.org/wiki/Fortran \"Fortran\") and [Python](https://en.wikipedia.org/wiki/Python_\\(programming_language\\) \"Python (programming language)\"). C/C++ programmers can use 'CUDA C/C++', compiled to [PTX](https://en.wikipedia.org/wiki/Parallel_Thread_Execution \"Parallel Thread Execution\") with [nvcc](https://en.wikipedia.org/wiki/NVIDIA_CUDA_Compiler \"NVIDIA CUDA Compiler\"), Nvidia's [LLVM](https://en.wikipedia.org/wiki/LLVM \"LLVM\")\\-based C/C++ compiler, or by clang itself.[\\[10\\]](#cite_note-10) Fortran programmers can use 'CUDA Fortran', compiled with the PGI CUDA Fortran compiler from [The Portland Group](https://en.wikipedia.org/wiki/The_Portland_Group \"The Portland Group\").\\[_[needs update](https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style/Dates_and_numbers#Chronological_items \"Wikipedia:Manual of Style/Dates and numbers\")_\\] Python programmers can use the cuNumeric library to accelerate applications on Nvidia GPUs.\n\nIn addition to libraries, compiler directives, CUDA C/C++ and CUDA Fortran, the CUDA platform supports other computational interfaces, including the [Khronos Group](https://en.wikipedia.org/wiki/Khronos_Group \"Khronos Group\")'s [OpenCL](https://en.wikipedia.org/wiki/OpenCL \"OpenCL\"),[\\[11\\]](#cite_note-11) Microsoft's [DirectCompute](https://en.wikipedia.org/wiki/DirectCompute \"DirectCompute\"), [OpenGL](https://en.wikipedia.org/wiki/OpenGL \"OpenGL\") Compute Shader and [C++ AMP](https://en.wikipedia.org/wiki/C%2B%2B_AMP \"C++ AMP\").[\\[12\\]](#cite_note-12) Third party wrappers are also available for [Python](https://en.wikipedia.org/wiki/Python_\\(programming_language\\) \"Python (programming language)\"), [Perl](https://en.wikipedia.org/wiki/Perl \"Perl\"), Fortran, [Java](https://en.wikipedia.org/wiki/Java_\\(programming_language\\) \"Java (programming language)\"), [Ruby](https://en.wikipedia.org/wiki/Ruby_\\(programming_language\\) \"Ruby (programming language)\"), [Lua](https://en.wikipedia.org/wiki/Lua_\\(programming_language\\) \"Lua (programming language)\"), [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp_\\(programming_language\\) \"Common Lisp (programming language)\"), [Haskell](https://en.wikipedia.org/wiki/Haskell_\\(programming_language\\) \"Haskell (programming language)\"), [R](https://en.wikipedia.org/wiki/R_\\(programming_language\\) \"R (programming language)\"), [MATLAB](https://en.wikipedia.org/wiki/MATLAB \"MATLAB\"), [IDL](https://en.wikipedia.org/wiki/IDL_\\(programming_language\\) \"IDL (programming language)\"), [Julia](https://en.wikipedia.org/wiki/Julia_\\(programming_language\\) \"Julia (programming language)\"), and native support in [Mathematica](https://en.wikipedia.org/wiki/Mathematica \"Mathematica\").\n\nIn the [computer game](https://en.wikipedia.org/wiki/Computer_game \"Computer game\") industry, GPUs are used for graphics rendering, and for [game physics calculations](https://en.wikipedia.org/wiki/Physics_processing_unit \"Physics processing unit\") (physical effects such as debris, smoke, fire, fluids); examples include [PhysX](https://en.wikipedia.org/wiki/PhysX \"PhysX\") and [Bullet](https://en.wikipedia.org/wiki/Bullet_\\(software\\) \"Bullet (software)\"). CUDA has also been used to accelerate non-graphical applications in [computational biology](https://en.wikipedia.org/wiki/Computational_biology \"Computational biology\"), [cryptography](https://en.wikipedia.org/wiki/Cryptography \"Cryptography\") and other fields by an [order of magnitude](https://en.wikipedia.org/wiki/Order_of_magnitude \"Order of magnitude\") or more.[\\[13\\]](#cite_note-Ioannidis08-13)[\\[14\\]](#cite_note-14)[\\[15\\]](#cite_note-Manavski2008-15)[\\[16\\]](#cite_note-16)[\\[17\\]](#cite_note-17)\n\nCUDA provides both a low level [API](https://en.wikipedia.org/wiki/API \"API\") (CUDA **Driver** API, non single-source) and a higher level API (CUDA **Runtime** API, single-source). The initial CUDA [SDK](https://en.wikipedia.org/wiki/Software_development_kit \"Software development kit\") was made public on 15 February 2007, for [Microsoft Windows](https://en.wikipedia.org/wiki/Microsoft_Windows \"Microsoft Windows\") and [Linux](https://en.wikipedia.org/wiki/Linux \"Linux\"). [Mac OS X](https://en.wikipedia.org/wiki/MacOS \"MacOS\") support was later added in version 2.0,[\\[18\\]](#cite_note-18) which supersedes the beta released February 14, 2008.[\\[19\\]](#cite_note-19) CUDA works with all Nvidia GPUs from the G8x series onwards, including [GeForce](https://en.wikipedia.org/wiki/Nvidia_GeForce \"Nvidia GeForce\"), [Quadro](https://en.wikipedia.org/wiki/Nvidia_Quadro \"Nvidia Quadro\") and the [Tesla](https://en.wikipedia.org/wiki/Nvidia_Tesla \"Nvidia Tesla\") line. CUDA is compatible with most standard operating systems.\n\nCUDA 8.0 comes with the following libraries (for compilation & runtime, in alphabetical order):\n\n*   cuBLAS – CUDA Basic Linear Algebra Subroutines library\n*   CUDART – CUDA Runtime library\n*   cuFFT – CUDA Fast Fourier Transform library\n*   cuRAND – CUDA Random Number Generation library\n*   cuSOLVER – CUDA based collection of dense and sparse direct solvers\n*   cuSPARSE – CUDA Sparse Matrix library\n*   NPP – NVIDIA Performance Primitives library\n*   nvGRAPH – NVIDIA Graph Analytics library\n*   NVML – NVIDIA Management Library\n*   NVRTC – NVIDIA Runtime Compilation library for CUDA C++\n\nCUDA 8.0 comes with these other software components:\n\n*   nView – NVIDIA nView Desktop Management Software\n*   NVWMI – NVIDIA Enterprise Management Toolkit\n*   GameWorks [PhysX](https://en.wikipedia.org/wiki/PhysX \"PhysX\") – is a multi-platform game physics engine\n\nCUDA 9.0–9.2 comes with these other components:\n\n*   CUTLASS 1.0 – custom linear algebra algorithms,\n*   NVIDIA Video Decoder was deprecated in CUDA 9.2; it is now available in NVIDIA Video Codec SDK\n\nCUDA 10 comes with these other components:\n\n*   nvJPEG – Hybrid (CPU and GPU) JPEG processing\n\nCUDA 11.0–11.8 comes with these other components:[\\[20\\]](#cite_note-20)[\\[21\\]](#cite_note-21)[\\[22\\]](#cite_note-22)[\\[23\\]](#cite_note-23)\n\n*   CUB is new one of more supported C++ libraries\n*   MIG multi instance GPU support\n*   nvJPEG2000 – [JPEG 2000](https://en.wikipedia.org/wiki/JPEG_2000 \"JPEG 2000\") encoder and decoder\n\nCUDA has several advantages over traditional general-purpose computation on GPUs (GPGPU) using graphics APIs:\n\n*   Scattered reads – code can read from arbitrary addresses in memory.\n*   Unified virtual memory (CUDA 4.0 and above)\n*   Unified memory (CUDA 6.0 and above)\n*   [Shared memory](https://en.wikipedia.org/wiki/Shared_memory_\\(interprocess_communication\\) \"Shared memory (interprocess communication)\") – CUDA exposes a fast shared memory region that can be shared among threads. This can be used as a user-managed cache, enabling higher bandwidth than is possible using texture lookups.[\\[24\\]](#cite_note-24)\n*   Faster downloads and readbacks to and from the GPU\n*   Full support for integer and bitwise operations, including integer texture lookups\n\n*   Whether for the host computer or the GPU device, all CUDA source code is now processed according to C++ syntax rules.[\\[25\\]](#cite_note-CUDA_Prog_v8-25) This was not always the case. Earlier versions of CUDA were based on C syntax rules.[\\[26\\]](#cite_note-26) As with the more general case of compiling C code with a C++ compiler, it is therefore possible that old C-style CUDA source code will either fail to compile or will not behave as originally intended.\n*   Interoperability with rendering languages such as OpenGL is one-way, with OpenGL having access to registered CUDA memory but CUDA not having access to OpenGL memory.\n*   Copying between host and device memory may incur a performance hit due to system bus bandwidth and latency (this can be partly alleviated with asynchronous memory transfers, handled by the GPU's DMA engine).\n*   Threads should be running in groups of at least 32 for best performance, with total number of threads numbering in the thousands. Branches in the program code do not affect performance significantly, provided that each of 32 threads takes the same execution path; the [SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data \"Single instruction, multiple data\") execution model becomes a significant limitation for any inherently divergent task (e.g. traversing a [space partitioning](https://en.wikipedia.org/wiki/Space_partitioning \"Space partitioning\") data structure during [ray tracing](https://en.wikipedia.org/wiki/Ray_tracing_\\(graphics\\) \"Ray tracing (graphics)\")).\n*   No emulation or fallback functionality is available for modern revisions.\n*   Valid C++ may sometimes be flagged and prevent compilation due to the way the compiler approaches optimization for target GPU device limitations.\\[_[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed \"Wikipedia:Citation needed\")_\\]\n*   C++ [run-time type information](https://en.wikipedia.org/wiki/Run-time_type_information \"Run-time type information\") (RTTI) and C++-style exception handling are only supported in host code, not in device code.\n*   In [single-precision](https://en.wikipedia.org/wiki/Single-precision_floating-point_format \"Single-precision floating-point format\") on first generation CUDA compute capability 1.x devices, [denormal numbers](https://en.wikipedia.org/wiki/Denormal_number \"Denormal number\") are unsupported and are instead flushed to zero, and the precision of both the division and square root operations are slightly lower than IEEE 754-compliant single precision math. Devices that support compute capability 2.0 and above support denormal numbers, and the division and square root operations are IEEE 754 compliant by default. However, users can obtain the prior faster gaming-grade math of compute capability 1.x devices if desired by setting compiler flags to disable accurate divisions and accurate square roots, and enable flushing denormal numbers to zero.[\\[27\\]](#cite_note-27)\n*   Unlike [OpenCL](https://en.wikipedia.org/wiki/OpenCL \"OpenCL\"), CUDA-enabled GPUs are only available from Nvidia as it is proprietary.[\\[28\\]](#cite_note-CUDA_products-28)[\\[1\\]](#cite_note-:0-1) Attempts to implement CUDA on other GPUs include:\n    *   Project Coriander: Converts CUDA C++11 source to OpenCL 1.2 C. A fork of CUDA-on-CL intended to run [TensorFlow](https://en.wikipedia.org/wiki/TensorFlow \"TensorFlow\").[\\[29\\]](#cite_note-29)[\\[30\\]](#cite_note-30)[\\[31\\]](#cite_note-31)\n    *   CU2CL: Convert CUDA 3.2 C++ to OpenCL C.[\\[32\\]](#cite_note-32)\n    *   [GPUOpen](https://en.wikipedia.org/wiki/GPUOpen \"GPUOpen\") HIP: A thin abstraction layer on top of CUDA and [ROCm](https://en.wikipedia.org/wiki/ROCm \"ROCm\") intended for AMD and Nvidia GPUs. Has a conversion tool for importing CUDA C++ source. Supports CUDA 4.0 plus C++11 and float16.\n    *   ZLUDA is a drop-in replacement for CUDA on AMD GPUs and formerly Intel GPUs with near-native performance.[\\[33\\]](#cite_note-33) The developer, Andrzej Janik, was separately contracted by both Intel and AMD to develop the software in 2021 and 2022, respectively. However, neither company decided to release it officially due to the lack of a business use case. AMD's contract included a clause that allowed Janik to release his code for AMD independently, allowing him to release the new version that only supports AMD GPUs.[\\[34\\]](#cite_note-34)\n    *   chipStar can compile and run CUDA/HIP programs on advanced OpenCL 3.0 or Level Zero platforms.[\\[35\\]](#cite_note-35)\n\nThis example code in [C++](https://en.wikipedia.org/wiki/C%2B%2B \"C++\") loads a texture from an image into an array on the GPU:\n\ntexture<float, 2, cudaReadModeElementType\\> tex;\n\nvoid foo()\n{\n  cudaArray\\* cu\\_array;\n\n  // Allocate array\n  cudaChannelFormatDesc description \\= cudaCreateChannelDesc<float\\>();\n  cudaMallocArray(&cu\\_array, &description, width, height);\n\n  // Copy image data to array\n  cudaMemcpyToArray(cu\\_array, image, width\\*height\\*sizeof(float), cudaMemcpyHostToDevice);\n\n  // Set texture parameters (default)\n  tex.addressMode\\[0\\] \\= cudaAddressModeClamp;\n  tex.addressMode\\[1\\] \\= cudaAddressModeClamp;\n  tex.filterMode \\= cudaFilterModePoint;\n  tex.normalized \\= false; // do not normalize coordinates\n\n  // Bind the array to the texture\n  cudaBindTextureToArray(tex, cu\\_array);\n\n  // Run kernel\n  dim3 blockDim(16, 16, 1);\n  dim3 gridDim((width + blockDim.x \\- 1)/ blockDim.x, (height + blockDim.y \\- 1) / blockDim.y, 1);\n  kernel<<< gridDim, blockDim, 0 \\>>>(d\\_data, height, width);\n\n  // Unbind the array from the texture\n  cudaUnbindTexture(tex);\n} //end foo()\n\n\\_\\_global\\_\\_ void kernel(float\\* odata, int height, int width)\n{\n   unsigned int x \\= blockIdx.x\\*blockDim.x + threadIdx.x;\n   unsigned int y \\= blockIdx.y\\*blockDim.y + threadIdx.y;\n   if (x < width && y < height) {\n      float c \\= tex2D(tex, x, y);\n      odata\\[y\\*width+x\\] \\= c;\n   }\n}\n\nBelow is an example given in [Python](https://en.wikipedia.org/wiki/Python_\\(programming_language\\) \"Python (programming language)\") that computes the product of two arrays on the GPU. The unofficial Python language bindings can be obtained from _PyCUDA_.[\\[36\\]](#cite_note-36)\n\nimport pycuda.compiler as comp\nimport pycuda.driver as drv\nimport numpy\nimport pycuda.autoinit\n\nmod \\= comp.SourceModule(\n    \"\"\"\n\\_\\_global\\_\\_ void multiply\\_them(float \\*dest, float \\*a, float \\*b)\n{\n  const int i = threadIdx.x;\n  dest\\[i\\] = a\\[i\\] \\* b\\[i\\];\n}\n\"\"\"\n)\n\nmultiply\\_them \\= mod.get\\_function(\"multiply\\_them\")\n\na \\= numpy.random.randn(400).astype(numpy.float32)\nb \\= numpy.random.randn(400).astype(numpy.float32)\n\ndest \\= numpy.zeros\\_like(a)\nmultiply\\_them(drv.Out(dest), drv.In(a), drv.In(b), block\\=(400, 1, 1))\n\nprint(dest \\- a \\* b)\n\nAdditional Python bindings to simplify matrix multiplication operations can be found in the program _pycublas_.[\\[37\\]](#cite_note-37)\n\n \nimport numpy\nfrom pycublas import CUBLASMatrix\n\nA \\= CUBLASMatrix(numpy.mat(\\[\\[1, 2, 3\\], \\[4, 5, 6\\]\\], numpy.float32))\nB \\= CUBLASMatrix(numpy.mat(\\[\\[2, 3\\], \\[4, 5\\], \\[6, 7\\]\\], numpy.float32))\nC \\= A \\* B\nprint(C.np\\_mat())\n\nwhile [CuPy](https://en.wikipedia.org/wiki/CuPy \"CuPy\") directly replaces NumPy:[\\[38\\]](#cite_note-38)\n\nimport cupy\n\na \\= cupy.random.randn(400)\nb \\= cupy.random.randn(400)\n\ndest \\= cupy.zeros\\_like(a)\n\nprint(dest \\- a \\* b)\n\nSupported CUDA Compute Capability versions for CUDA SDK version and Microarchitecture (by code name):\n\nCompute Capability (CUDA SDK support vs. Microarchitecture)\n\nCUDA SDK  \nVersion(s)\n\n[Tesla](https://en.wikipedia.org/wiki/Tesla_\\(microarchitecture\\) \"Tesla (microarchitecture)\")\n\n[Fermi](https://en.wikipedia.org/wiki/Fermi_\\(microarchitecture\\) \"Fermi (microarchitecture)\")\n\n[Kepler](https://en.wikipedia.org/wiki/Kepler_\\(microarchitecture\\) \"Kepler (microarchitecture)\")  \n(Early)\n\n[Kepler](https://en.wikipedia.org/wiki/Kepler_\\(microarchitecture\\) \"Kepler (microarchitecture)\")  \n(Late)\n\n[Maxwell](https://en.wikipedia.org/wiki/Maxwell_\\(microarchitecture\\) \"Maxwell (microarchitecture)\")\n\n[Pascal](https://en.wikipedia.org/wiki/Pascal_\\(microarchitecture\\) \"Pascal (microarchitecture)\")\n\n[Volta](https://en.wikipedia.org/wiki/Volta_\\(microarchitecture\\) \"Volta (microarchitecture)\")\n\n[Turing](https://en.wikipedia.org/wiki/Turing_\\(microarchitecture\\) \"Turing (microarchitecture)\")\n\n[Ampere](https://en.wikipedia.org/wiki/Ampere_\\(microarchitecture\\) \"Ampere (microarchitecture)\")\n\n[Ada  \nLovelace](https://en.wikipedia.org/wiki/Ada_Lovelace_\\(microarchitecture\\) \"Ada Lovelace (microarchitecture)\")\n\n[Hopper](https://en.wikipedia.org/wiki/Hopper_\\(microarchitecture\\) \"Hopper (microarchitecture)\")\n\n[Blackwell](https://en.wikipedia.org/wiki/Blackwell_\\(microarchitecture\\) \"Blackwell (microarchitecture)\")\n\n1.0[\\[39\\]](#cite_note-39)\n\n1.0 – 1.1\n\n1.1\n\n1.0 – 1.1+x\n\n2.0\n\n1.0 – 1.1+x\n\n2.1 – 2.3.1[\\[40\\]](#cite_note-40)[\\[41\\]](#cite_note-41)[\\[42\\]](#cite_note-42)[\\[43\\]](#cite_note-43)\n\n1.0 – 1.3\n\n3.0 – 3.1[\\[44\\]](#cite_note-44)[\\[45\\]](#cite_note-45)\n\n1.0\n\n2.0\n\n3.2[\\[46\\]](#cite_note-46)\n\n1.0\n\n2.1\n\n4.0 – 4.2\n\n1.0\n\n2.1\n\n5.0 – 5.5\n\n1.0\n\n3.5\n\n6.0\n\n1.0\n\n3.2\n\n3.5\n\n6.5\n\n1.1\n\n3.7\n\n5.x\n\n7.0 – 7.5\n\n2.0\n\n5.x\n\n8.0\n\n2.0\n\n6.x\n\n9.0 – 9.2\n\n3.0\n\n7.0 – 7.2\n\n10.0 – 10.2\n\n3.0\n\n7.5\n\n11.0[\\[47\\]](#cite_note-47)\n\n3.5\n\n8.0\n\n11.1 – 11.4[\\[48\\]](#cite_note-48)\n\n3.5\n\n8.6\n\n11.5 – 11.7.1[\\[49\\]](#cite_note-49)\n\n3.5\n\n8.7\n\n11.8[\\[50\\]](#cite_note-50)\n\n3.5\n\n8.9\n\n9.0\n\n12.0 – 12.5\n\n5.0\n\n9.0\n\nNote: CUDA SDK 10.2 is the last official release for macOS, as support will not be available for macOS in newer releases.\n\nCUDA Compute Capability by version with associated GPU semiconductors and GPU card models (separated by their various application areas):\n\nCompute Capability, GPU semiconductors and Nvidia GPU board products\n\nCompute  \ncapability  \n(version)\n\n[Micro-  \narchitecture](https://en.wikipedia.org/wiki/Microarchitecture \"Microarchitecture\")\n\nGPUs\n\n[GeForce](https://en.wikipedia.org/wiki/GeForce \"GeForce\")\n\n[Quadro](https://en.wikipedia.org/wiki/Quadro \"Quadro\"), [NVS](https://en.wikipedia.org/wiki/Quadro#For_business_NVS \"Quadro\")\n\n[Tesla/Datacenter](https://en.wikipedia.org/wiki/Nvidia_Tesla \"Nvidia Tesla\")\n\n[Tegra](https://en.wikipedia.org/wiki/Tegra \"Tegra\"),  \n[Jetson](https://en.wikipedia.org/wiki/Nvidia_Jetson \"Nvidia Jetson\"),  \n[DRIVE](https://en.wikipedia.org/wiki/Nvidia_Drive \"Nvidia Drive\")\n\n1.0\n\n[Tesla](https://en.wikipedia.org/wiki/Tesla_\\(microarchitecture\\) \"Tesla (microarchitecture)\")\n\nG80\n\nGeForce 8800 Ultra, GeForce 8800 GTX, GeForce 8800 GTS(G80)\n\nQuadro FX 5600, Quadro FX 4600, Quadro Plex 2100 S4\n\nTesla C870, Tesla D870, Tesla S870\n\n1.1\n\nG92, G94, G96, G98, G84, G86\n\nGeForce GTS 250, GeForce 9800 GX2, GeForce 9800 GTX, GeForce 9800 GT, GeForce 8800 GTS(G92), GeForce 8800 GT, GeForce 9600 GT, GeForce 9500 GT, GeForce 9400 GT, GeForce 8600 GTS, GeForce 8600 GT, GeForce 8500 GT,  \nGeForce G110M, GeForce 9300M GS, GeForce 9200M GS, GeForce 9100M G, GeForce 8400M GT, GeForce G105M\n\nQuadro FX 4700 X2, Quadro FX 3700, Quadro FX 1800, Quadro FX 1700, Quadro FX 580, Quadro FX 570, Quadro FX 470, Quadro FX 380, Quadro FX 370, Quadro FX 370 Low Profile, Quadro NVS 450, Quadro NVS 420, Quadro NVS 290, Quadro NVS 295, Quadro Plex 2100 D4,  \nQuadro FX 3800M, Quadro FX 3700M, Quadro FX 3600M, Quadro FX 2800M, Quadro FX 2700M, Quadro FX 1700M, Quadro FX 1600M, Quadro FX 770M, Quadro FX 570M, Quadro FX 370M, Quadro FX 360M, Quadro NVS 320M, Quadro NVS 160M, Quadro NVS 150M, Quadro NVS 140M, Quadro NVS 135M, Quadro NVS 130M, Quadro NVS 450, Quadro NVS 420,[\\[51\\]](#cite_note-51) Quadro NVS 295\n\n1.2\n\nGT218, GT216, GT215\n\nGeForce GT 340\\*, GeForce GT 330\\*, GeForce GT 320\\*, GeForce 315\\*, GeForce 310\\*, GeForce GT 240, GeForce GT 220, GeForce 210,  \nGeForce GTS 360M, GeForce GTS 350M, GeForce GT 335M, GeForce GT 330M, GeForce GT 325M, GeForce GT 240M, GeForce G210M, GeForce 310M, GeForce 305M\n\nQuadro FX 380 Low Profile, Quadro FX 1800M, Quadro FX 880M, Quadro FX 380M,  \nNvidia NVS 300, NVS 5100M, NVS 3100M, NVS 2100M, ION\n\n1.3\n\nGT200, GT200b\n\nGeForce GTX 295, GTX 285, GTX 280, GeForce GTX 275, GeForce GTX 260\n\nQuadro FX 5800, Quadro FX 4800, Quadro FX 4800 for Mac, Quadro FX 3800, Quadro CX, Quadro Plex 2200 D2\n\nTesla C1060, Tesla S1070, Tesla M1060\n\n2.0\n\n[Fermi](https://en.wikipedia.org/wiki/Fermi_\\(microarchitecture\\) \"Fermi (microarchitecture)\")\n\nGF100, GF110\n\nGeForce GTX 590, GeForce GTX 580, GeForce GTX 570, GeForce GTX 480, GeForce GTX 470, GeForce GTX 465,  \nGeForce GTX 480M\n\nQuadro 6000, Quadro 5000, Quadro 4000, Quadro 4000 for Mac, Quadro Plex 7000,  \nQuadro 5010M, Quadro 5000M\n\nTesla C2075, Tesla C2050/C2070, Tesla M2050/M2070/M2075/M2090\n\n2.1\n\nGF104, GF106 GF108, GF114, GF116, GF117, GF119\n\nGeForce GTX 560 Ti, GeForce GTX 550 Ti, GeForce GTX 460, GeForce GTS 450, GeForce GTS 450\\*, GeForce GT 640 (GDDR3), GeForce GT 630, GeForce GT 620, GeForce GT 610, GeForce GT 520, GeForce GT 440, GeForce GT 440\\*, GeForce GT 430, GeForce GT 430\\*, GeForce GT 420\\*,  \nGeForce GTX 675M, GeForce GTX 670M, GeForce GT 635M, GeForce GT 630M, GeForce GT 625M, GeForce GT 720M, GeForce GT 620M, GeForce 710M, GeForce 610M, GeForce 820M, GeForce GTX 580M, GeForce GTX 570M, GeForce GTX 560M, GeForce GT 555M, GeForce GT 550M, GeForce GT 540M, GeForce GT 525M, GeForce GT 520MX, GeForce GT 520M, GeForce GTX 485M, GeForce GTX 470M, GeForce GTX 460M, GeForce GT 445M, GeForce GT 435M, GeForce GT 420M, GeForce GT 415M, GeForce 710M, GeForce 410M\n\nQuadro 2000, Quadro 2000D, Quadro 600,  \nQuadro 4000M, Quadro 3000M, Quadro 2000M, Quadro 1000M,  \nNVS 310, NVS 315, NVS 5400M, NVS 5200M, NVS 4200M\n\n3.0\n\n[Kepler](https://en.wikipedia.org/wiki/Kepler_\\(microarchitecture\\) \"Kepler (microarchitecture)\")\n\nGK104, GK106, GK107\n\nGeForce GTX 770, GeForce GTX 760, GeForce GT 740, GeForce GTX 690, GeForce GTX 680, GeForce GTX 670, GeForce GTX 660 Ti, GeForce GTX 660, GeForce GTX 650 Ti BOOST, GeForce GTX 650 Ti, GeForce GTX 650,  \nGeForce GTX 880M, GeForce GTX 870M, GeForce GTX 780M, GeForce GTX 770M, GeForce GTX 765M, GeForce GTX 760M, GeForce GTX 680MX, GeForce GTX 680M, GeForce GTX 675MX, GeForce GTX 670MX, GeForce GTX 660M, GeForce GT 750M, GeForce GT 650M, GeForce GT 745M, GeForce GT 645M, GeForce GT 740M, GeForce GT 730M, GeForce GT 640M, GeForce GT 640M LE, GeForce GT 735M, GeForce GT 730M\n\nQuadro K5000, Quadro K4200, Quadro K4000, Quadro K2000, Quadro K2000D, Quadro K600, Quadro K420,  \nQuadro K500M, Quadro K510M, Quadro K610M, Quadro K1000M, Quadro K2000M, Quadro K1100M, Quadro K2100M, Quadro K3000M, Quadro K3100M, Quadro K4000M, Quadro K5000M, Quadro K4100M, Quadro K5100M,  \nNVS 510, Quadro 410\n\nTesla K10, GRID K340, GRID K520, GRID K2\n\n3.2\n\nGK20A\n\nTegra K1,  \nJetson TK1\n\n3.5\n\nGK110, GK208\n\nGeForce GTX Titan Z, GeForce GTX Titan Black, GeForce GTX Titan, GeForce GTX 780 Ti, GeForce GTX 780, GeForce GT 640 (GDDR5), GeForce GT 630 v2, GeForce GT 730, GeForce GT 720, GeForce GT 710, GeForce GT 740M (64-bit, DDR3), GeForce GT 920M\n\nQuadro K6000, Quadro K5200\n\nTesla K40, Tesla K20x, Tesla K20\n\n3.7\n\nGK210\n\nTesla K80\n\n5.0\n\n[Maxwell](https://en.wikipedia.org/wiki/Maxwell_\\(microarchitecture\\) \"Maxwell (microarchitecture)\")\n\nGM107, GM108\n\nGeForce GTX 750 Ti, GeForce GTX 750, GeForce GTX 960M, GeForce GTX 950M, GeForce 940M, GeForce 930M, GeForce GTX 860M, GeForce GTX 850M, GeForce 845M, GeForce 840M, GeForce 830M\n\nQuadro K1200, Quadro K2200, Quadro K620, Quadro M2000M, Quadro M1000M, Quadro M600M, Quadro K620M, NVS 810\n\nTesla M10\n\n5.2\n\nGM200, GM204, GM206\n\nGeForce GTX Titan X, GeForce GTX 980 Ti, GeForce GTX 980, GeForce GTX 970, GeForce GTX 960, GeForce GTX 950, GeForce GTX 750 SE,  \nGeForce GTX 980M, GeForce GTX 970M, GeForce GTX 965M\n\nQuadro M6000 24GB, Quadro M6000, Quadro M5000, Quadro M4000, Quadro M2000, Quadro M5500,  \nQuadro M5000M, Quadro M4000M, Quadro M3000M\n\nTesla M4, Tesla M40, Tesla M6, Tesla M60\n\n5.3\n\nGM20B\n\nTegra X1,  \nJetson TX1,  \nJetson Nano,  \nDRIVE CX,  \nDRIVE PX\n\n6.0\n\n[Pascal](https://en.wikipedia.org/wiki/Pascal_\\(microarchitecture\\) \"Pascal (microarchitecture)\")\n\nGP100\n\nQuadro GP100\n\nTesla P100\n\n6.1\n\nGP102, GP104, GP106, GP107, GP108\n\nNvidia TITAN Xp, Titan X,  \nGeForce GTX 1080 Ti, GTX 1080, GTX 1070 Ti, GTX 1070, GTX 1060,  \nGTX 1050 Ti, GTX 1050, GT 1030, GT 1010,  \nMX350, MX330, MX250, MX230, MX150, MX130, MX110\n\nQuadro P6000, Quadro P5000, Quadro P4000, Quadro P2200, Quadro P2000, Quadro P1000, Quadro P400, Quadro P500, Quadro P520, Quadro P600,  \nQuadro P5000(Mobile), Quadro P4000(Mobile), Quadro P3000(Mobile)\n\nTesla P40, Tesla P6, Tesla P4\n\n6.2\n\nGP10B[\\[52\\]](#cite_note-52)\n\nTegra X2, Jetson TX2, DRIVE PX 2\n\n7.0\n\n[Volta](https://en.wikipedia.org/wiki/Volta_\\(microarchitecture\\) \"Volta (microarchitecture)\")\n\nGV100\n\nNVIDIA TITAN V\n\nQuadro GV100\n\nTesla V100, Tesla V100S\n\n7.2\n\nGV10B[\\[53\\]](#cite_note-53)\n\nGV11B[\\[54\\]](#cite_note-54)[\\[55\\]](#cite_note-55)\n\nTegra Xavier,  \nJetson Xavier NX,  \nJetson AGX Xavier,  \nDRIVE AGX Xavier,  \nDRIVE AGX Pegasus,  \nClara AGX\n\n7.5\n\n[Turing](https://en.wikipedia.org/wiki/Turing_\\(microarchitecture\\) \"Turing (microarchitecture)\")\n\nTU102, TU104, TU106, TU116, TU117\n\nNVIDIA TITAN RTX,  \nGeForce RTX 2080 Ti, RTX 2080 Super, RTX 2080, RTX 2070 Super, RTX 2070, RTX 2060 Super, RTX 2060 12GB, RTX 2060,  \nGeForce GTX 1660 Ti, GTX 1660 Super, GTX 1660, GTX 1650 Super, GTX 1650, MX550, MX450\n\nQuadro RTX 8000, Quadro RTX 6000, Quadro RTX 5000, Quadro RTX 4000, T1000, T600, T400  \nT1200(mobile), T600(mobile), T500(mobile), Quadro T2000(mobile), Quadro T1000(mobile)\n\nTesla T4\n\n8.0\n\n[Ampere](https://en.wikipedia.org/wiki/Ampere_\\(microarchitecture\\) \"Ampere (microarchitecture)\")\n\nGA100\n\nA100 80GB, A100 40GB, A30\n\n8.6\n\nGA102, GA103, GA104, GA106, GA107\n\nGeForce RTX 3090 Ti, RTX 3090, RTX 3080 Ti, RTX 3080 12GB, RTX 3080, RTX 3070 Ti, RTX 3070, RTX 3060 Ti, RTX 3060, RTX 3050, RTX 3050 Ti(mobile), RTX 3050(mobile), RTX 2050(mobile), MX570\n\nRTX A6000, RTX A5500, RTX A5000, RTX A4500, RTX A4000, RTX A2000  \nRTX A5000(mobile), RTX A4000(mobile), RTX A3000(mobile), RTX A2000(mobile)\n\nA40, A16, A10, A2\n\n8.7\n\nGA10B\n\nJetson Orin Nano,  \nJetson Orin NX,  \nJetson AGX Orin,  \nDRIVE AGX Orin,  \nDRIVE AGX Pegasus OA,  \nClara Holoscan\n\n8.9\n\n[Ada Lovelace](https://en.wikipedia.org/wiki/Ada_Lovelace_\\(microarchitecture\\) \"Ada Lovelace (microarchitecture)\")[\\[56\\]](#cite_note-56)\n\nAD102, AD103, AD104, AD106, AD107\n\nGeForce RTX 4090, RTX 4080 Super, RTX 4080, RTX 4070 Ti Super, RTX 4070 Ti, RTX 4070 Super, RTX 4070, RTX 4060 Ti, RTX 4060\n\nRTX 6000 Ada, RTX 5880 Ada, RTX 5000 Ada, RTX 4500 Ada, RTX 4000 Ada, RTX 4000 SFF\n\nL40S, L40, L20, L4, L2\n\n9.0\n\n[Hopper](https://en.wikipedia.org/wiki/Hopper_\\(microarchitecture\\) \"Hopper (microarchitecture)\")\n\nGH100\n\nH200, H100\n\n10.0\n\n[Blackwell](https://en.wikipedia.org/wiki/Blackwell_\\(microarchitecture\\) \"Blackwell (microarchitecture)\")\n\nGB100\n\nB200, B100\n\n10.x\n\nGB202, GB203, GB205, GB206, GB207\n\nGeForce RTX 5090, RTX 5080\n\nB40\n\nCompute  \ncapability  \n(version)\n\n[Micro-  \narchitecture](https://en.wikipedia.org/wiki/Microarchitecture \"Microarchitecture\")\n\nGPUs\n\n[GeForce](https://en.wikipedia.org/wiki/GeForce \"GeForce\")\n\n[Quadro](https://en.wikipedia.org/wiki/Quadro \"Quadro\"), [NVS](https://en.wikipedia.org/wiki/Quadro#For_business_NVS \"Quadro\")\n\n[Tesla/Datacenter](https://en.wikipedia.org/wiki/Nvidia_Tesla \"Nvidia Tesla\")\n\n[Tegra](https://en.wikipedia.org/wiki/Tegra \"Tegra\"),  \n[Jetson](https://en.wikipedia.org/wiki/Nvidia_Jetson \"Nvidia Jetson\"),  \n[DRIVE](https://en.wikipedia.org/wiki/Nvidia_Drive \"Nvidia Drive\")\n\n'\\*' – [OEM](https://en.wikipedia.org/wiki/Original_equipment_manufacturer \"Original equipment manufacturer\")\\-only products\n\n## Version features and specifications\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=8 \"Edit section: Version features and specifications\")\\]\n\n![](https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Ambox_current_red_Americas.svg/42px-Ambox_current_red_Americas.svg.png)\n\nThis section needs to be **updated**. The reason given is: Missing CUDA compute capability 10.x (Blackwell). Please help update this article to reflect recent events or newly available information. _(March 2024)_\n\nFeature support (unlisted features are supported for all compute capabilities)\n\nCompute capability (version)\n\n1.0, 1.1\n\n1.2, 1.3\n\n2.x\n\n3.0\n\n3.2\n\n3.5, 3.7, 5.x, 6.x, 7.0, 7.2\n\n7.5\n\n8.x\n\n9.0\n\nWarp vote functions (\\_\\_all(), \\_\\_any())\n\nNo\n\nYes\n\nWarp vote functions (\\_\\_ballot())\n\nNo\n\nYes\n\nMemory fence functions (\\_\\_threadfence\\_system())\n\nSynchronization functions (\\_\\_syncthreads\\_count(), \\_\\_syncthreads\\_and(), \\_\\_syncthreads\\_or())\n\nSurface functions\n\n3D grid of thread blocks\n\nWarp shuffle functions\n\nNo\n\nYes\n\nUnified memory programming\n\nFunnel shift\n\nNo\n\nYes\n\nDynamic parallelism\n\nNo\n\nYes\n\nUniform Datapath[\\[57\\]](#cite_note-57)\n\nNo\n\nYes\n\nHardware-accelerated async-copy\n\nNo\n\nYes\n\nHardware-accelerated _split arrive/wait barrier_\n\nWarp-level support for reduction ops\n\nL2 cache residency management\n\nDPX instructions for accelerated dynamic programming\n\nNo\n\nYes\n\nDistributed shared memory\n\nThread block cluster\n\nTensor memory accelerator (TMA) unit\n\nFeature support (unlisted features are supported for all compute capabilities)\n\n1.0,1.1\n\n1.2,1.3\n\n2.x\n\n3.0\n\n3.2\n\n3.5, 3.7, 5.x, 6.x, 7.0, 7.2\n\n7.5\n\n8.x\n\n9.0\n\nCompute capability (version)\n\n[\\[58\\]](#cite_note-58)\n\nData type\n\nOperation\n\nSupported since  \n\nAtomic Operation\n\nSupported since  \nfor global memory\n\nSupported since  \nfor shared memory\n\n8-bit integer  \nsigned/unsigned\n\nloading, storing, conversion\n\n1.0\n\n—\n\n—\n\n16-bit integer  \nsigned/unsigned\n\ngeneral operations\n\n1.0\n\natomicCAS()\n\n3.5\n\n32-bit integer  \nsigned/unsigned\n\ngeneral operations\n\n1.0\n\natomic functions\n\n1.1\n\n1.2\n\n64-bit integer  \nsigned/unsigned\n\ngeneral operations\n\n1.0\n\natomic functions\n\n1.2\n\n2.0\n\nany 128-bit trivially copyable type\n\ngeneral operations\n\nNo\n\natomicExch, atomicCAS\n\n9.0\n\n16-bit floating point  \nFP16\n\naddition, subtraction,  \nmultiplication, comparison,  \nwarp shuffle functions, conversion\n\n5.3\n\nhalf2 atomic addition\n\n6.0\n\natomic addition\n\n7.0\n\n16-bit floating point  \nBF16\n\naddition, subtraction,  \nmultiplication, comparison,  \nwarp shuffle functions, conversion\n\n8.0\n\natomic addition\n\n8.0\n\n32-bit floating point\n\ngeneral operations\n\n1.0\n\natomicExch()\n\n1.1\n\n1.2\n\natomic addition\n\n2.0\n\n32-bit floating point float2 and float4\n\ngeneral operations\n\nNo\n\natomic addition\n\n9.0\n\n64-bit floating point\n\ngeneral operations\n\n1.3\n\natomic addition\n\n6.0\n\nNote: Any missing lines or empty entries do reflect some lack of information on that exact item.[\\[59\\]](#cite_note-59)\n\nFMA per cycle per tensor core[\\[60\\]](#cite_note-60)\n\nSupported since\n\n7.0\n\n7.2\n\n7.5 Workstation\n\n7.5 Desktop\n\n8.0\n\n8.6 Workstation\n\n8.7\n\n8.6 Desktop\n\n8.9 Desktop\n\n8.9 Workstation\n\n9.0\n\n10.0\n\nData Type\n\nFor dense matrices\n\nFor sparse matrices\n\n1st Gen (8x/SM)\n\n1st Gen? (8x/SM)\n\n2nd Gen (8x/SM)\n\n3rd Gen (4x/SM)\n\n4th Gen (4x/SM)\n\n5th Gen (4x/SM)\n\n1-bit values (AND)\n\n8.0 as  \nexperimental\n\nNo\n\nNo\n\n4096\n\n2048\n\nspeed tbd\n\n1-bit values (XOR)\n\n7.5–8.9 as  \nexperimental\n\nNo\n\n1024\n\nDeprecated or removed?\n\n4-bit integers\n\n8.0–8.9 as  \nexperimental\n\n256\n\n1024\n\n512\n\n4-bit floating point FP4 (E2M1?)\n\n10.0\n\nNo\n\n4096\n\n6-bit floating point FP6 (E3M2 and E2M3?)\n\n10.0\n\nNo\n\n2048\n\n8-bit integers\n\n7.2\n\n8.0\n\nNo\n\n128\n\n128\n\n512\n\n256\n\n1024\n\n2048\n\n8-bit floating point FP8 (E4M3 and E5M2) with FP16 accumulate\n\n8.9\n\nNo\n\n256\n\n8-bit floating point FP8 (E4M3 and E5M2) with FP32 accumulate\n\n16-bit floating point FP16 with FP16 accumulate\n\n7.0\n\n8.0\n\n64\n\n64\n\n64\n\n256\n\n128\n\n512\n\n1024\n\n16-bit floating point FP16 with FP32 accumulate\n\n32\n\n64\n\n128\n\n16-bit floating point BF16 with FP32 accumulate\n\n7.5[\\[61\\]](#cite_note-61)\n\n8.0\n\nNo\n\n32-bit (19 bits used) floating point TF32\n\nspeed tbd (32?)\n\n128\n\n32\n\n64\n\n256\n\n512\n\n64-bit floating point\n\n8.0\n\nNo\n\nNo\n\n16\n\nspeed tbd\n\n32\n\n16\n\nNote: Any missing lines or empty entries do reflect some lack of information on that exact item.[\\[62\\]](#cite_note-62)[\\[63\\]](#cite_note-63) [\\[64\\]](#cite_note-64) [\\[65\\]](#cite_note-65) [\\[66\\]](#cite_note-66) [\\[67\\]](#cite_note-67)\n\nTensor Core Composition\n\n7.0\n\n7.2, 7.5\n\n8.0, 8.6\n\n8.7\n\n8.9\n\n9.0\n\nDot Product Unit Width in FP16 units (in bytes)[\\[68\\]](#cite_note-68)[\\[69\\]](#cite_note-69)[\\[70\\]](#cite_note-70)[\\[71\\]](#cite_note-71)\n\n4 (8)\n\n8 (16)\n\n4 (8)\n\n16 (32)\n\nDot Product Units per Tensor Core\n\n16\n\n32\n\nTensor Cores per SM partition\n\n2\n\n1\n\nFull throughput (Bytes/cycle)[\\[72\\]](#cite_note-72) per SM partition[\\[73\\]](#cite_note-73)\n\n256\n\n512\n\n256\n\n1024\n\nFP Tensor Cores: Minimum cycles for warp-wide matrix calculation\n\n8\n\n4\n\n8\n\nFP Tensor Cores: Minimum Matrix Shape for full throughput (Bytes)[\\[74\\]](#cite_note-74)\n\n2048\n\nINT Tensor Cores: Minimum cycles for warp-wide matrix calculation\n\nNo\n\n4\n\nINT Tensor Cores: Minimum Matrix Shape for full throughput (Bytes)\n\nNo\n\n1024\n\n2048\n\n1024\n\n[\\[75\\]](#cite_note-75)[\\[76\\]](#cite_note-76)[\\[77\\]](#cite_note-77)[\\[78\\]](#cite_note-78)\n\nFP64 Tensor Core Composition\n\n8.0\n\n8.6\n\n8.7\n\n8.9\n\n9.0\n\nDot Product Unit Width in FP64 units (in bytes)\n\n4 (32)\n\ntbd\n\n4 (32)\n\nDot Product Units per Tensor Core\n\n4\n\ntbd\n\n8\n\nTensor Cores per SM partition\n\n1\n\nFull throughput (Bytes/cycle)[\\[79\\]](#cite_note-79) per SM partition[\\[80\\]](#cite_note-80)\n\n128\n\ntbd\n\n256\n\nMinimum cycles for warp-wide matrix calculation\n\n16\n\ntbd\n\nMinimum Matrix Shape for full throughput (Bytes)[\\[81\\]](#cite_note-81)\n\n2048\n\n### Technical specification\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=11 \"Edit section: Technical specification\")\\]\n\nTechnical specifications\n\nCompute capability (version)\n\n1.0\n\n1.1\n\n1.2\n\n1.3\n\n2.x\n\n3.0\n\n3.2\n\n3.5\n\n3.7\n\n5.0\n\n5.2\n\n5.3\n\n6.0\n\n6.1\n\n6.2\n\n7.0\n\n7.2\n\n7.5\n\n8.0\n\n8.6\n\n8.7\n\n8.9\n\n9.0\n\nMaximum number of resident grids per device  \n(concurrent kernel execution, can be lower for specific devices)\n\n1\n\n16\n\n4\n\n32\n\n16\n\n128\n\n32\n\n16\n\n128\n\n16\n\n128\n\nMaximum dimensionality of grid of thread blocks\n\n2\n\n3\n\nMaximum x-dimension of a grid of thread blocks\n\n65535\n\n231 − 1\n\nMaximum y-, or z-dimension of a grid of thread blocks\n\n65535\n\nMaximum dimensionality of thread block\n\n3\n\nMaximum x- or y-dimension of a block\n\n512\n\n1024\n\nMaximum z-dimension of a block\n\n64\n\nMaximum number of threads per block\n\n512\n\n1024\n\nWarp size\n\n32\n\nMaximum number of resident blocks per multiprocessor\n\n8\n\n16\n\n32\n\n16\n\n32\n\n16\n\n24\n\n32\n\nMaximum number of resident warps per multiprocessor\n\n24\n\n32\n\n48\n\n64\n\n32\n\n64\n\n48\n\n64\n\nMaximum number of resident threads per multiprocessor\n\n768\n\n1024\n\n1536\n\n2048\n\n1024\n\n2048\n\n1536\n\n2048\n\nNumber of 32-bit regular registers per multiprocessor\n\n8 K\n\n16 K\n\n32 K\n\n64 K\n\n128 K\n\n64 K\n\nNumber of 32-bit uniform registers per multiprocessor\n\nNo\n\n2 K[\\[82\\]](#cite_note-82)\n\n[\\[83\\]](#cite_note-83)\n\nMaximum number of 32-bit registers per thread block\n\n8 K\n\n16 K\n\n32 K\n\n64 K\n\n32 K\n\n64 K\n\n32 K\n\n64 K\n\n32 K\n\n64 K\n\nMaximum number of 32-bit regular registers per thread\n\n124\n\n63\n\n255\n\nMaximum number of 32-bit uniform registers per warp\n\nNo\n\n63[\\[84\\]](#cite_note-84)\n\n[\\[85\\]](#cite_note-85)\n\nAmount of shared memory per multiprocessor  \n(out of overall shared memory + L1 cache, where applicable)\n\n16 KiB\n\n16 / 48 KiB (of 64 KiB)\n\n16 / 32 / 48 KiB (of 64 KiB)\n\n80 / 96 / 112 KiB (of 128 KiB)\n\n64 KiB\n\n96 KiB\n\n64 KiB\n\n96 KiB\n\n64 KiB\n\n0 / 8 / 16 / 32 / 64 / 96 KiB (of 128 KiB)\n\n32 / 64 KiB (of 96 KiB)\n\n0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 KiB (of 192 KiB)\n\n0 / 8 / 16 / 32 / 64 / 100 KiB (of 128 KiB)\n\n0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 KiB (of 192 KiB)\n\n0 / 8 / 16 / 32 / 64 / 100 KiB (of 128 KiB)\n\n0 / 8 / 16 / 32 / 64 / 100 / 132 / 164 / 196 / 228 KiB (of 256 KiB)\n\nMaximum amount of shared memory per thread block\n\n16 KiB\n\n48 KiB\n\n96 KiB\n\n48 KiB\n\n64 KiB\n\n163 KiB\n\n99 KiB\n\n163 KiB\n\n99 KiB\n\n227 KiB\n\nNumber of shared memory banks\n\n16\n\n32\n\nAmount of local memory per thread\n\n16 KiB\n\n512 KiB\n\nConstant memory size accessible by CUDA C/C++  \n(1 bank, PTX can access 11 banks, SASS can access 18 banks)\n\n64 KiB\n\nCache working set per multiprocessor for constant memory\n\n8 KiB\n\n4 KiB\n\n8 KiB\n\nCache working set per multiprocessor for texture memory\n\n16 KiB per TPC\n\n24 KiB per TPC\n\n12 KiB\n\n12 – 48 KiB[\\[86\\]](#cite_note-86)\n\n24 KiB\n\n48 KiB\n\n32 KiB[\\[87\\]](#cite_note-87)\n\n24 KiB\n\n48 KiB\n\n24 KiB\n\n32 – 128 KiB\n\n32 – 64 KiB\n\n28 – 192 KiB\n\n28 – 128 KiB\n\n28 – 192 KiB\n\n28 – 128 KiB\n\n28 – 256 KiB\n\nMaximum width for 1D texture reference bound to a CUDA  \narray\n\n8192\n\n65536\n\n131072\n\nMaximum width for 1D texture reference bound to linear  \nmemory\n\n227\n\n228\n\n227\n\n228\n\n227\n\n228\n\nMaximum width and number of layers for a 1D layered  \ntexture reference\n\n8192 × 512\n\n16384 × 2048\n\n32768 x 2048\n\nMaximum width and height for 2D texture reference bound  \nto a CUDA array\n\n65536 × 32768\n\n65536 × 65535\n\n131072 x 65536\n\nMaximum width and height for 2D texture reference bound  \nto a linear memory\n\n65000 x 65000\n\n65536 x 65536\n\n131072 x 65000\n\nMaximum width and height for 2D texture reference bound  \nto a CUDA array supporting texture gather\n\n—\n\n16384 x 16384\n\n32768 x 32768\n\nMaximum width, height, and number of layers for a 2D  \nlayered texture reference\n\n8192 × 8192 × 512\n\n16384 × 16384 × 2048\n\n32768 x 32768 x 2048\n\nMaximum width, height and depth for a 3D texture  \nreference bound to linear memory or a CUDA array\n\n20483\n\n40963\n\n163843\n\nMaximum width (and height) for a cubemap texture reference\n\n—\n\n16384\n\n32768\n\nMaximum width (and height) and number of layers  \nfor a cubemap layered texture reference\n\n—\n\n16384 × 2046\n\n32768 × 2046\n\nMaximum number of textures that can be bound to a  \nkernel\n\n128\n\n256\n\nMaximum width for a 1D surface reference bound to a  \nCUDA array\n\nNot  \nsupported\n\n65536\n\n16384\n\n32768\n\nMaximum width and number of layers for a 1D layered  \nsurface reference\n\n65536 × 2048\n\n16384 × 2048\n\n32768 × 2048\n\nMaximum width and height for a 2D surface reference  \nbound to a CUDA array\n\n65536 × 32768\n\n16384 × 65536\n\n131072 × 65536\n\nMaximum width, height, and number of layers for a 2D  \nlayered surface reference\n\n65536 × 32768 × 2048\n\n16384 × 16384 × 2048\n\n32768 × 32768 × 2048\n\nMaximum width, height, and depth for a 3D surface  \nreference bound to a CUDA array\n\n65536 × 32768 × 2048\n\n4096 × 4096 × 4096\n\n16384 × 16384 × 16384\n\nMaximum width (and height) for a cubemap surface reference bound to a CUDA array\n\n32768\n\n16384\n\n32768\n\nMaximum width and number of layers for a cubemap  \nlayered surface reference\n\n32768 × 2046\n\n16384 × 2046\n\n32768 × 2046\n\nMaximum number of surfaces that can be bound to a  \nkernel\n\n8\n\n16\n\n32\n\nMaximum number of instructions per kernel\n\n2 million\n\n512 million\n\nMaximum number of Thread Blocks per Thread Block Cluster[\\[88\\]](#cite_note-88)\n\nNo\n\n16\n\nTechnical specifications\n\n1.0\n\n1.1\n\n1.2\n\n1.3\n\n2.x\n\n3.0\n\n3.2\n\n3.5\n\n3.7\n\n5.0\n\n5.2\n\n5.3\n\n6.0\n\n6.1\n\n6.2\n\n7.0\n\n7.2\n\n7.5\n\n8.0\n\n8.6\n\n8.7\n\n8.9\n\n9.0\n\nCompute capability (version)\n\n[\\[89\\]](#cite_note-89)\n\n[\\[90\\]](#cite_note-90)\n\n### Multiprocessor architecture\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=12 \"Edit section: Multiprocessor architecture\")\\]\n\nArchitecture specifications\n\nCompute capability (version)\n\n1.0\n\n1.1\n\n1.2\n\n1.3\n\n2.0\n\n2.1\n\n3.0\n\n3.2\n\n3.5\n\n3.7\n\n5.0\n\n5.2\n\n5.3\n\n6.0\n\n6.1\n\n6.2\n\n7.0\n\n7.2\n\n7.5\n\n8.0\n\n8.6\n\n8.7\n\n8.9\n\n9.0\n\nNumber of ALU lanes for INT32 arithmetic operations\n\n8\n\n32\n\n48\n\n192[\\[91\\]](#cite_note-91)\n\n128\n\n128\n\n64\n\n128\n\n128\n\n64\n\n64\n\n64\n\nNumber of ALU lanes for any INT32 or FP32 arithmetic operation\n\n—\n\n—\n\nNumber of ALU lanes for FP32 arithmetic operations\n\n64\n\n64\n\n128\n\n128\n\nNumber of ALU lanes for FP16x2 arithmetic operations\n\nNo\n\n1\n\n128[\\[92\\]](#cite_note-92)\n\n128[\\[93\\]](#cite_note-93)\n\n64[\\[94\\]](#cite_note-94)\n\nNumber of ALU lanes for FP64 arithmetic operations\n\nNo\n\n1\n\n16 by FP32[\\[95\\]](#cite_note-95)\n\n4 by FP32[\\[96\\]](#cite_note-96)\n\n8\n\n8 / 64[\\[97\\]](#cite_note-depending_on_model-97)\n\n64\n\n4[\\[98\\]](#cite_note-98)\n\n32\n\n4\n\n32\n\n2\n\n32\n\n2\n\n2?\n\n2\n\n64\n\nNumber of Load/Store Units\n\n4 per 2 SM\n\n8 per 2 SM\n\n8 per 2 SM / 3 SM[\\[97\\]](#cite_note-depending_on_model-97)\n\n8 per 3 SM\n\n16\n\n32\n\n16\n\n32\n\n16\n\n32\n\nNumber of special function units for single-precision floating-point transcendental functions\n\n2[\\[99\\]](#cite_note-99)\n\n4\n\n8\n\n32\n\n16\n\n32\n\n16\n\nNumber of texture mapping units (TMU)\n\n4 per 2 SM\n\n8 per 2 SM\n\n8 per 2 / 3SM[\\[97\\]](#cite_note-depending_on_model-97)\n\n8 per 3 SM\n\n4\n\n4 / 8[\\[97\\]](#cite_note-depending_on_model-97)\n\n16\n\n8\n\n16\n\n8\n\n4\n\nNumber of ALU lanes for uniform INT32 arithmetic operations\n\nNo\n\n2[\\[100\\]](#cite_note-100)\n\nNumber of tensor cores\n\nNo\n\n8 (1st gen.)[\\[101\\]](#cite_note-inside-volta-101)\n\n0 / 8[\\[97\\]](#cite_note-depending_on_model-97) (2nd gen.)\n\n4 (3rd gen.)\n\n4 (4th gen.)\n\nNumber of raytracing cores\n\nNo\n\n0 / 1[\\[97\\]](#cite_note-depending_on_model-97) (1st gen.)\n\nNo\n\n1 (2nd gen.)\n\nNo\n\n1 (3rd gen.)\n\nNo\n\nNumber of SM Partitions = Processing Blocks[\\[102\\]](#cite_note-102)\n\n1\n\n4\n\n2\n\n4\n\nNumber of warp schedulers per SM partition\n\n1\n\n2\n\n4\n\n1\n\nMax number of new instructions issued each cycle by a single scheduler[\\[103\\]](#cite_note-103)\n\n2[\\[104\\]](#cite_note-104)\n\n1\n\n2[\\[105\\]](#cite_note-105)\n\n2\n\n1\n\nSize of unified memory for data cache and shared memory\n\n16 KiB[\\[106\\]](#cite_note-shared_memory_only,_no_data_cache-106)\n\n16 KiB[\\[106\\]](#cite_note-shared_memory_only,_no_data_cache-106)\n\n64 KiB\n\n128 KiB\n\n64 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n96 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n64 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n64 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n96 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n64 KiB SM + 24 KiB L1 (separate)[\\[107\\]](#cite_note-ReferenceA-107)\n\n128 KiB\n\n96 KiB[\\[108\\]](#cite_note-108)\n\n192 KiB\n\n128 KiB\n\n192 KiB\n\n128 KiB\n\n256 KiB\n\nSize of L3 instruction cache per GPU\n\n32 KiB[\\[109\\]](#cite_note-109)\n\nuse L2 Data Cache\n\nSize of L2 instruction cache per Texture Processor Cluster (TPC)\n\n8 KiB\n\nSize of L1.5 instruction cache per SM[\\[110\\]](#cite_note-110)\n\n4 KiB\n\n32 KiB\n\n32 KiB\n\n48 KiB[\\[111\\]](#cite_note-111)\n\n128 KiB\n\n32 KiB\n\n128 KiB\n\n~46 KiB[\\[112\\]](#cite_note-112)\n\n128 KiB[\\[113\\]](#cite_note-113)\n\nSize of L1 instruction cache per SM\n\n8 KiB\n\n8 KiB\n\nSize of L0 instruction cache per SM partition\n\nonly 1 partition per SM\n\nNo\n\n12 KiB\n\n16 KiB?[\\[114\\]](#cite_note-114)\n\n32 KiB\n\nInstruction Width[\\[115\\]](#cite_note-115)\n\n32 bits instructions and 64 bits instructions[\\[116\\]](#cite_note-116)\n\n64 bits instructions + 64 bits control logic every 7 instructions\n\n64 bits instructions + 64 bits control logic every 3 instructions\n\n128 bits combined instruction and control logic\n\nMemory Bus Width per Memory Partition in bits\n\n64 ((G)DDR)\n\n32 ((G)DDR)\n\n512 (HBM)\n\n32 ((G)DDR)\n\n512 (HBM)\n\n32 ((G)DDR)\n\n512 (HBM)\n\n32 ((G)DDR)\n\n512 (HBM)\n\nL2 Cache per Memory Partition\n\n16 KiB[\\[117\\]](#cite_note-ReferenceB-117)\n\n32 KiB[\\[117\\]](#cite_note-ReferenceB-117)\n\n128 KiB\n\n256 KiB\n\n1 MiB\n\n512 KiB\n\n128 KiB\n\n512 KiB\n\n256 KiB\n\n128 KiB\n\n768 KiB\n\n64 KiB\n\n512 KiB\n\n4 MiB\n\n512 KiB\n\n8 MiB[\\[118\\]](#cite_note-118)\n\n5 MiB\n\nNumber of Render Output Units (ROP) per memory partition (or per GPC in later models)\n\n4\n\n8\n\n4\n\n8\n\n16\n\n8\n\n12\n\n8\n\n4\n\n16\n\n2\n\n8\n\n16\n\n16 per GPC\n\n3 per GPC\n\n16 per GPC\n\nArchitecture specifications\n\n1.0\n\n1.1\n\n1.2\n\n1.3\n\n2.0\n\n2.1\n\n3.0\n\n3.2\n\n3.5\n\n3.7\n\n5.0\n\n5.2\n\n5.3\n\n6.0\n\n6.1\n\n6.2\n\n7.0\n\n7.2\n\n7.5\n\n8.0\n\n8.6\n\n8.7\n\n8.9\n\n9.0\n\nCompute capability (version)\n\n[\\[119\\]](#cite_note-119)\n\nFor more information read the Nvidia CUDA programming guide.[\\[120\\]](#cite_note-120)\n\n## Current and future usages of CUDA architecture\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=13 \"Edit section: Current and future usages of CUDA architecture\")\\]\n\n*   Accelerated rendering of 3D graphics\n*   Accelerated interconversion of video file formats\n*   Accelerated [encryption](https://en.wikipedia.org/wiki/Encryption \"Encryption\"), [decryption](https://en.wikipedia.org/wiki/Decryption \"Decryption\") and [compression](https://en.wikipedia.org/wiki/Data_compression \"Data compression\")\n*   [Bioinformatics](https://en.wikipedia.org/wiki/Bioinformatics \"Bioinformatics\"), e.g. [NGS](https://en.wikipedia.org/wiki/Massive_parallel_sequencing \"Massive parallel sequencing\") DNA sequencing BarraCUDA[\\[121\\]](#cite_note-121)\n*   Distributed calculations, such as predicting the native conformation of [proteins](https://en.wikipedia.org/wiki/Proteins \"Proteins\")\n*   Medical analysis simulations, for example [virtual reality](https://en.wikipedia.org/wiki/Virtual_reality \"Virtual reality\") based on [CT](https://en.wikipedia.org/wiki/X-ray_computed_tomography \"X-ray computed tomography\") and [MRI](https://en.wikipedia.org/wiki/Magnetic_resonance_imaging \"Magnetic resonance imaging\") scan images\n*   Physical simulations,[\\[122\\]](#cite_note-122) in particular in [fluid dynamics](https://en.wikipedia.org/wiki/Fluid_dynamics \"Fluid dynamics\")\n*   [Neural network](https://en.wikipedia.org/wiki/Neural_network \"Neural network\") training in [machine learning](https://en.wikipedia.org/wiki/Machine_learning \"Machine learning\") problems\n*   [Large Language Model](https://en.wikipedia.org/wiki/Large_Language_Model \"Large Language Model\") inference\n*   [Face recognition](https://en.wikipedia.org/wiki/Face_recognition \"Face recognition\")\n*   [Volunteer computing](https://en.wikipedia.org/wiki/Volunteer_computing \"Volunteer computing\") projects, such as [SETI@home](https://en.wikipedia.org/wiki/SETI@home \"SETI@home\") and other projects using [BOINC](https://en.wikipedia.org/wiki/Berkeley_Open_Infrastructure_for_Network_Computing \"Berkeley Open Infrastructure for Network Computing\") software\n*   [Molecular dynamics](https://en.wikipedia.org/wiki/Molecular_dynamics \"Molecular dynamics\")\n*   Mining [cryptocurrencies](https://en.wikipedia.org/wiki/Cryptocurrencies \"Cryptocurrencies\")\n*   [Structure from motion](https://en.wikipedia.org/wiki/Structure_from_motion \"Structure from motion\") (SfM) software\n\n## Comparison with competitors\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=14 \"Edit section: Comparison with competitors\")\\]\n\nCUDA competes with other GPU computing stacks: [Intel OneAPI](https://en.wikipedia.org/wiki/OneAPI_\\(compute_acceleration\\) \"OneAPI (compute acceleration)\") and [AMD ROCm](https://en.wikipedia.org/wiki/ROCm \"ROCm\").\n\nWhereas Nvidia's CUDA is closed-source, Intel's OneAPI and AMD's ROCm are open source.\n\n**oneAPI** is an initiative based in open standards, created to support software development for multiple hardware architectures.[\\[123\\]](#cite_note-123) The oneAPI libraries must implement open specifications that are discussed publicly by the Special Interest Groups, offering the possibility for any developer or organization to implement their own versions of oneAPI libraries.[\\[124\\]](#cite_note-124)[\\[125\\]](#cite_note-125)\n\nOriginally made by Intel, other hardware adopters include Fujitsu and Huawei.\n\n#### Unified Acceleration Foundation (UXL)\n\n\\[[edit](https://en.wikipedia.org/w/index.php?title=CUDA&action=edit&section=16 \"Edit section: Unified Acceleration Foundation (UXL)\")\\]\n\nUnified Acceleration Foundation (UXL) is a new technology consortium working on the continuation of the OneAPI initiative, with the goal to create a new open standard accelerator software ecosystem, related open standards and specification projects through Working Groups and Special Interest Groups (SIGs). The goal is to offer open alternatives to Nvidia's CUDA. The main companies behind it are Intel, Google, ARM, Qualcomm, Samsung, Imagination, and VMware.[\\[126\\]](#cite_note-126)\n\nMain article: [ROCm](https://en.wikipedia.org/wiki/ROCm \"ROCm\")\n\n**ROCm**[\\[127\\]](#cite_note-127) is an open source software stack for [graphics processing unit](https://en.wikipedia.org/wiki/Graphics_processing_unit \"Graphics processing unit\") (GPU) programming from [Advanced Micro Devices](https://en.wikipedia.org/wiki/Advanced_Micro_Devices \"Advanced Micro Devices\") (AMD).\n\n*   [SYCL](https://en.wikipedia.org/wiki/SYCL \"SYCL\") – an open standard from [Khronos Group](https://en.wikipedia.org/wiki/Khronos_Group \"Khronos Group\") for programming a variety of platforms, including GPUs, with _single-source_ modern C++, similar to higher-level CUDA **Runtime** API (_single-source_)\n*   [BrookGPU](https://en.wikipedia.org/wiki/BrookGPU \"BrookGPU\") – the Stanford University graphics group's compiler\n*   [Array programming](https://en.wikipedia.org/wiki/Array_programming \"Array programming\")\n*   [Parallel computing](https://en.wikipedia.org/wiki/Parallel_computing \"Parallel computing\")\n*   [Stream processing](https://en.wikipedia.org/wiki/Stream_processing \"Stream processing\")\n*   [rCUDA](https://en.wikipedia.org/wiki/RCUDA \"RCUDA\") – an API for computing on remote computers\n*   [Molecular modeling on GPUs](https://en.wikipedia.org/wiki/Molecular_modeling_on_GPUs \"Molecular modeling on GPUs\")\n*   [Vulkan](https://en.wikipedia.org/wiki/Vulkan \"Vulkan\") – low-level, high-performance 3D graphics and computing API\n*   [OptiX](https://en.wikipedia.org/wiki/OptiX \"OptiX\") – ray tracing API by NVIDIA\n*   [CUDA binary](https://en.wikipedia.org/wiki/CUDA_binary \"CUDA binary\") (cubin) – a type of fat binary\n*   [Numerical Library Collection](https://en.wikipedia.org/wiki/Numerical_Library_Collection \"Numerical Library Collection\") – by NEC for their vector processor\n\n1.  ^ [Jump up to: _**a**_](#cite_ref-:0_1-0) [_**b**_](#cite_ref-:0_1-1) Shah, Agam. [\"Nvidia not totally against third parties making CUDA chips\"](https://www.theregister.com/2021/11/10/nvidia_cuda_silicon/). _www.theregister.com_. Retrieved 2024-04-25.\n2.  **[^](#cite_ref-2 \"Jump up\")** Nvidia. [\"What is CUDA?\"](https://nvidia.custhelp.com/app/answers/detail/a_id/2132/~/what-is-cuda%3F). _Nvidia_. Retrieved 21 March 2024.\n3.  ^ [Jump up to: _**a**_](#cite_ref-CUDA_intro_-_TomsHardware_3-0) [_**b**_](#cite_ref-CUDA_intro_-_TomsHardware_3-1) Abi-Chahla, Fedy (June 18, 2008). [\"Nvidia's CUDA: The End of the CPU?\"](https://www.tomshardware.com/reviews/nvidia-cuda-gpu,1954.html). Tom's Hardware. Retrieved May 17, 2015.\n4.  **[^](#cite_ref-4 \"Jump up\")** Zunitch, Peter (2018-01-24). [\"CUDA vs. OpenCL vs. OpenGL\"](https://www.videomaker.com/article/c15/19313-cuda-vs-opencl-vs-opengl). _Videomaker_. Retrieved 2018-09-16.\n5.  **[^](#cite_ref-5 \"Jump up\")** [\"OpenCL\"](https://developer.nvidia.com/opencl). _NVIDIA Developer_. 2013-04-24. Retrieved 2019-11-04.\n6.  **[^](#cite_ref-6 \"Jump up\")** [\"Nvidia CUDA Home Page\"](https://developer.nvidia.com/cuda-zone). 18 July 2017.\n7.  **[^](#cite_ref-CUDA_intro_-_AnandTech_7-0 \"Jump up\")** Shimpi, Anand Lal; Wilson, Derek (November 8, 2006). [\"Nvidia's GeForce 8800 (G80): GPUs Re-architected for DirectX 10\"](https://www.anandtech.com/show/2116/8). AnandTech. Retrieved May 16, 2015.\n8.  **[^](#cite_ref-8 \"Jump up\")** [\"Introduction — nsight-visual-studio-edition 12.6 documentation\"](https://docs.nvidia.com/nsight-visual-studio-edition/introduction/index.html#cuda-debugger). _docs.nvidia.com_. Retrieved 2024-10-10.\n9.  **[^](#cite_ref-9 \"Jump up\")** Witt, Stephen (2023-11-27). [\"How Jensen Huang's Nvidia Is Powering the A.I. Revolution\"](https://www.newyorker.com/magazine/2023/12/04/how-jensen-huangs-nvidia-is-powering-the-ai-revolution). _The New Yorker_. [ISSN](https://en.wikipedia.org/wiki/ISSN_\\(identifier\\) \"ISSN (identifier)\") [0028-792X](https://search.worldcat.org/issn/0028-792X). Retrieved 2023-12-10.\n10.  **[^](#cite_ref-10 \"Jump up\")** [\"CUDA LLVM Compiler\"](https://developer.nvidia.com/cuda-llvm-compiler). 7 May 2012.\n11.  **[^](#cite_ref-11 \"Jump up\")** [First OpenCL demo on a GPU](https://www.youtube.com/watch?v=r1sN1ELJfNo) on [YouTube](https://en.wikipedia.org/wiki/YouTube_video_\\(identifier\\) \"YouTube video (identifier)\")\n12.  **[^](#cite_ref-12 \"Jump up\")** [DirectCompute Ocean Demo Running on Nvidia CUDA-enabled GPU](https://www.youtube.com/watch?v=K1I4kts5mqc) on [YouTube](https://en.wikipedia.org/wiki/YouTube_video_\\(identifier\\) \"YouTube video (identifier)\")\n13.  **[^](#cite_ref-Ioannidis08_13-0 \"Jump up\")** Vasiliadis, Giorgos; Antonatos, Spiros; Polychronakis, Michalis; Markatos, Evangelos P.; Ioannidis, Sotiris (September 2008). [\"Gnort: High Performance Network Intrusion Detection Using Graphics Processors\"](http://www.ics.forth.gr/dcs/Activities/papers/gnort.raid08.pdf) (PDF). _Recent Advances in Intrusion Detection_. Lecture Notes in Computer Science. Vol. 5230. pp. 116–134. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1007/978-3-540-87403-4\\_7](https://doi.org/10.1007%2F978-3-540-87403-4_7). [ISBN](https://en.wikipedia.org/wiki/ISBN_\\(identifier\\) \"ISBN (identifier)\") [978-3-540-87402-7](https://en.wikipedia.org/wiki/Special:BookSources/978-3-540-87402-7 \"Special:BookSources/978-3-540-87402-7\").\n14.  **[^](#cite_ref-14 \"Jump up\")** Schatz, Michael C.; Trapnell, Cole; Delcher, Arthur L.; Varshney, Amitabh (2007). [\"High-throughput sequence alignment using Graphics Processing Units\"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2222658). _BMC Bioinformatics_. **8**: 474. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1186/1471-2105-8-474](https://doi.org/10.1186%2F1471-2105-8-474). [PMC](https://en.wikipedia.org/wiki/PMC_\\(identifier\\) \"PMC (identifier)\") [2222658](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2222658). [PMID](https://en.wikipedia.org/wiki/PMID_\\(identifier\\) \"PMID (identifier)\") [18070356](https://pubmed.ncbi.nlm.nih.gov/18070356).\n15.  **[^](#cite_ref-Manavski2008_15-0 \"Jump up\")** Manavski, Svetlin A.; Giorgio, Valle (2008). [\"CUDA compatible GPU cards as efficient hardware accelerators for Smith-Waterman sequence alignment\"](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2323659). _BMC Bioinformatics_. **10** (Suppl 2): S10. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1186/1471-2105-9-S2-S10](https://doi.org/10.1186%2F1471-2105-9-S2-S10). [PMC](https://en.wikipedia.org/wiki/PMC_\\(identifier\\) \"PMC (identifier)\") [2323659](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2323659). [PMID](https://en.wikipedia.org/wiki/PMID_\\(identifier\\) \"PMID (identifier)\") [18387198](https://pubmed.ncbi.nlm.nih.gov/18387198).\n16.  **[^](#cite_ref-16 \"Jump up\")** [\"Pyrit – Google Code\"](https://code.google.com/p/pyrit/).\n17.  **[^](#cite_ref-17 \"Jump up\")** [\"Use your Nvidia GPU for scientific computing\"](https://web.archive.org/web/20081228022142/http://boinc.berkeley.edu/cuda.php). BOINC. 2008-12-18. Archived from [the original](http://boinc.berkeley.edu/cuda.php) on 2008-12-28. Retrieved 2017-08-08.\n18.  **[^](#cite_ref-18 \"Jump up\")** [\"Nvidia CUDA Software Development Kit (CUDA SDK) – Release Notes Version 2.0 for MAC OS X\"](https://web.archive.org/web/20090106020401/http://developer.download.nvidia.com/compute/cuda/sdk/website/doc/CUDA_SDK_release_notes_macosx.txt). Archived from [the original](http://developer.download.nvidia.com/compute/cuda/sdk/website/doc/CUDA_SDK_release_notes_macosx.txt) on 2009-01-06.\n19.  **[^](#cite_ref-19 \"Jump up\")** [\"CUDA 1.1 – Now on Mac OS X\"](https://web.archive.org/web/20081122105633/http://news.developer.nvidia.com/2008/02/cuda-11---now-o.html). February 14, 2008. Archived from [the original](http://news.developer.nvidia.com/2008/02/cuda-11---now-o.html) on November 22, 2008.\n20.  **[^](#cite_ref-20 \"Jump up\")** [\"CUDA 11 Features Revealed\"](https://developer.nvidia.com/blog/cuda-11-features-revealed/). 14 May 2020.\n21.  **[^](#cite_ref-21 \"Jump up\")** [\"CUDA Toolkit 11.1 Introduces Support for GeForce RTX 30 Series and Quadro RTX Series GPUs\"](https://developer.nvidia.com/blog/cuda-11-1-introduces-support-rtx-30-series/). 23 September 2020.\n22.  **[^](#cite_ref-22 \"Jump up\")** [\"Enhancing Memory Allocation with New NVIDIA CUDA 11.2 Features\"](https://developer.nvidia.com/blog/enhancing-memory-allocation-with-new-cuda-11-2-features/). 16 December 2020.\n23.  **[^](#cite_ref-23 \"Jump up\")** [\"Exploring the New Features of CUDA 11.3\"](https://developer.nvidia.com/blog/exploring-the-new-features-of-cuda-11-3/). 16 April 2021.\n24.  **[^](#cite_ref-24 \"Jump up\")** Silberstein, Mark; [Schuster, Assaf](https://en.wikipedia.org/wiki/Assaf_Schuster \"Assaf Schuster\"); Geiger, Dan; Patney, Anjul; Owens, John D. (2008). [\"Efficient computation of sum-products on GPUs through software-managed cache\"](https://escholarship.org/content/qt8js4v3f7/qt8js4v3f7.pdf?t=ptt3te) (PDF). [_Proceedings of the 22nd annual international conference on Supercomputing – ICS '08_](https://escholarship.org/content/qt8js4v3f7/qt8js4v3f7.pdf?t=ptt3te) (PDF). Proceedings of the 22nd annual international conference on Supercomputing – ICS '08. pp. 309–318. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1145/1375527.1375572](https://doi.org/10.1145%2F1375527.1375572). [ISBN](https://en.wikipedia.org/wiki/ISBN_\\(identifier\\) \"ISBN (identifier)\") [978-1-60558-158-3](https://en.wikipedia.org/wiki/Special:BookSources/978-1-60558-158-3 \"Special:BookSources/978-1-60558-158-3\").\n25.  **[^](#cite_ref-CUDA_Prog_v8_25-0 \"Jump up\")** [\"CUDA C Programming Guide v8.0\"](http://docs.nvidia.com/cuda/pdf/CUDA_C_Programming_Guide.pdf) (PDF). _nVidia Developer Zone_. January 2017. p. 19. Retrieved 22 March 2017.\n26.  **[^](#cite_ref-26 \"Jump up\")** [\"NVCC forces c++ compilation of .cu files\"](https://devtalk.nvidia.com/default/topic/508479/cuda-programming-and-performance/nvcc-forces-c-compilation-of-cu-files/#entry1340190). 29 November 2011.\n27.  **[^](#cite_ref-27 \"Jump up\")** Whitehead, Nathan; Fit-Florea, Alex. [\"Precision & Performance: Floating Point and IEEE 754 Compliance for Nvidia GPUs\"](https://developer.nvidia.com/sites/default/files/akamai/cuda/files/NVIDIA-CUDA-Floating-Point.pdf) (PDF). [Nvidia](https://en.wikipedia.org/wiki/Nvidia \"Nvidia\"). Retrieved November 18, 2014.\n28.  **[^](#cite_ref-CUDA_products_28-0 \"Jump up\")** [\"CUDA-Enabled Products\"](https://www.nvidia.com/object/cuda_learn_products.html). _CUDA Zone_. Nvidia Corporation. Retrieved 2008-11-03.\n29.  **[^](#cite_ref-29 \"Jump up\")** [\"Coriander Project: Compile CUDA Codes To OpenCL, Run Everywhere\"](http://www.phoronix.com/scan.php?page=news_item&px=CUDA-On-CL-Coriander). Phoronix.\n30.  **[^](#cite_ref-30 \"Jump up\")** Perkins, Hugh (2017). [\"cuda-on-cl\"](http://www.iwocl.org/wp-content/uploads/iwocl2017-hugh-perkins-cuda-cl.pdf) (PDF). IWOCL. Retrieved August 8, 2017.\n31.  **[^](#cite_ref-31 \"Jump up\")** [\"hughperkins/coriander: Build NVIDIA® CUDA™ code for OpenCL™ 1.2 devices\"](https://github.com/hughperkins/coriander). GitHub. May 6, 2019.\n32.  **[^](#cite_ref-32 \"Jump up\")** [\"CU2CL Documentation\"](http://chrec.cs.vt.edu/cu2cl/documentation.php). _chrec.cs.vt.edu_.\n33.  **[^](#cite_ref-33 \"Jump up\")** [\"GitHub – vosen/ZLUDA\"](https://github.com/vosen/ZLUDA). _[GitHub](https://en.wikipedia.org/wiki/GitHub \"GitHub\")_.\n34.  **[^](#cite_ref-34 \"Jump up\")** Larabel, Michael (2024-02-12), [\"AMD Quietly Funded A Drop-In CUDA Implementation Built On ROCm: It's Now Open-Source\"](https://www.phoronix.com/review/radeon-cuda-zluda), _[Phoronix](https://en.wikipedia.org/wiki/Phoronix_Test_Suite#Phoronix_website \"Phoronix Test Suite\")_, retrieved 2024-02-12\n35.  **[^](#cite_ref-35 \"Jump up\")** [\"GitHub – chip-spv/chipStar\"](https://github.com/chip-spv/chipStar). _[GitHub](https://en.wikipedia.org/wiki/GitHub \"GitHub\")_.\n36.  **[^](#cite_ref-36 \"Jump up\")** [\"PyCUDA\"](http://mathema.tician.de/software/pycuda).\n37.  **[^](#cite_ref-37 \"Jump up\")** [\"pycublas\"](https://web.archive.org/web/20090420124748/http://kered.org/blog/2009-04-13/easy-python-numpy-cuda-cublas/). Archived from [the original](http://kered.org/blog/2009-04-13/easy-python-numpy-cuda-cublas/) on 2009-04-20. Retrieved 2017-08-08.\n38.  **[^](#cite_ref-38 \"Jump up\")** [\"CuPy\"](https://cupy.dev/). Retrieved 2020-01-08.\n39.  **[^](#cite_ref-39 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 1.0\"](http://developer.download.nvidia.com/compute/cuda/1.0/NVIDIA_CUDA_Programming_Guide_1.0.pdf) (PDF). June 23, 2007.\n40.  **[^](#cite_ref-40 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 2.1\"](http://developer.download.nvidia.com/compute/cuda/2_1/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.1.pdf) (PDF). December 8, 2008.\n41.  **[^](#cite_ref-41 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 2.2\"](http://developer.download.nvidia.com/compute/cuda/2_2/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.pdf) (PDF). April 2, 2009.\n42.  **[^](#cite_ref-42 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 2.2.1\"](http://developer.download.nvidia.com/compute/cuda/2_21/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.2.1.pdf) (PDF). May 26, 2009.\n43.  **[^](#cite_ref-43 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 2.3.1\"](http://developer.download.nvidia.com/compute/cuda/2_3/toolkit/docs/NVIDIA_CUDA_Programming_Guide_2.3.pdf) (PDF). August 26, 2009.\n44.  **[^](#cite_ref-44 \"Jump up\")** [\"NVIDIA CUDA Programming Guide. Version 3.0\"](http://developer.download.nvidia.com/compute/cuda/3_0/toolkit/docs/NVIDIA_CUDA_ProgrammingGuide.pdf) (PDF). February 20, 2010.\n45.  **[^](#cite_ref-45 \"Jump up\")** [\"NVIDIA CUDA C Programming Guide. Version 3.1.1\"](http://developer.download.nvidia.com/compute/cuda/3_1/toolkit/docs/NVIDIA_CUDA_C_ProgrammingGuide_3.1.pdf) (PDF). July 21, 2010.\n46.  **[^](#cite_ref-46 \"Jump up\")** [\"NVIDIA CUDA C Programming Guide. Version 3.2\"](http://developer.download.nvidia.com/compute/cuda/3_2_prod/toolkit/docs/CUDA_C_Programming_Guide.pdf) (PDF). November 9, 2010.\n47.  **[^](#cite_ref-47 \"Jump up\")** [\"CUDA 11.0 Release Notes\"](https://docs.nvidia.com/cuda/archive/11.0/cuda-toolkit-release-notes/index.html). _NVIDIA Developer_.\n48.  **[^](#cite_ref-48 \"Jump up\")** [\"CUDA 11.1 Release Notes\"](https://docs.nvidia.com/cuda/archive/11.1.0/cuda-toolkit-release-notes/index.html). _NVIDIA Developer_.\n49.  **[^](#cite_ref-49 \"Jump up\")** [\"CUDA 11.5 Release Notes\"](https://docs.nvidia.com/cuda/archive/11.5.0/cuda-toolkit-release-notes/index.html). _NVIDIA Developer_.\n50.  **[^](#cite_ref-50 \"Jump up\")** [\"CUDA 11.8 Release Notes\"](https://docs.nvidia.com/cuda/archive/11.8.0/cuda-toolkit-release-notes/index.html). _NVIDIA Developer_.\n51.  **[^](#cite_ref-51 \"Jump up\")** [\"NVIDIA Quadro NVS 420 Specs\"](https://www.techpowerup.com/gpu-specs/quadro-nvs-420.c1448). _TechPowerUp GPU Database_. 25 August 2023.\n52.  **[^](#cite_ref-52 \"Jump up\")** [Larabel, Michael](https://en.wikipedia.org/wiki/Michael_Larabel \"Michael Larabel\") (March 29, 2017). [\"NVIDIA Rolls Out Tegra X2 GPU Support In Nouveau\"](http://www.phoronix.com/scan.php?page=news_item&px=Tegra-X2-Nouveau-Support). [Phoronix](https://en.wikipedia.org/wiki/Phoronix \"Phoronix\"). Retrieved August 8, 2017.\n53.  **[^](#cite_ref-53 \"Jump up\")** [Nvidia Xavier Specs](https://www.techpowerup.com/gpudb/3232/xavier) on TechPowerUp (preliminary)\n54.  **[^](#cite_ref-54 \"Jump up\")** [\"Welcome — Jetson LinuxDeveloper Guide 34.1 documentation\"](https://docs.nvidia.com/jetson/l4t/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/power_management_jetson_xavier.html).\n55.  **[^](#cite_ref-55 \"Jump up\")** [\"NVIDIA Bringing up Open-Source Volta GPU Support for Their Xavier SoC\"](https://www.phoronix.com/scan.php?page=news_item&px=NVIDIA-Nouveau-GV11B-Volta-Xav).\n56.  **[^](#cite_ref-56 \"Jump up\")** [\"NVIDIA Ada Lovelace Architecture\"](https://www.nvidia.com/en-us/geforce/ada-lovelace-architecture/).\n57.  **[^](#cite_ref-57 \"Jump up\")** [Dissecting the Turing GPU Architecture through Microbenchmarking](https://developer.download.nvidia.com/video/gputechconf/gtc/2019/presentation/s9839-discovering-the-turing-t4-gpu-architecture-with-microbenchmarks.pdf)\n58.  **[^](#cite_ref-58 \"Jump up\")** [\"H.1. Features and Technical Specifications – Table 13. Feature Support per Compute Capability\"](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications). _docs.nvidia.com_. Retrieved 2020-09-23.\n59.  **[^](#cite_ref-59 \"Jump up\")** [\"CUDA C++ Programming Guide\"](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications).\n60.  **[^](#cite_ref-60 \"Jump up\")** Fused-Multiply-Add, actually executed, Dense Matrix\n61.  **[^](#cite_ref-61 \"Jump up\")** as SASS since 7.5, as PTX since 8.0\n62.  **[^](#cite_ref-62 \"Jump up\")** [\"Technical brief. NVIDIA Jetson AGX Orin Series\"](https://www.nvidia.com/content/dam/en-zz/Solutions/gtcf21/jetson-orin/nvidia-jetson-agx-orin-technical-brief.pdf) (PDF). _nvidia.com_. Retrieved 5 September 2023.\n63.  **[^](#cite_ref-63 \"Jump up\")** [\"NVIDIA Ampere GA102 GPU Architecture\"](https://images.nvidia.com/aem-dam/en-zz/Solutions/geforce/ampere/pdf/NVIDIA-ampere-GA102-GPU-Architecture-Whitepaper-V1.pdf) (PDF). _nvidia.com_. Retrieved 5 September 2023.\n64.  **[^](#cite_ref-64 \"Jump up\")** Luo, Weile; Fan, Ruibo; Li, Zeyu; Du, Dayou; Wang, Qiang; Chu, Xiaowen (2024). \"Benchmarking and Dissecting the Nvidia Hopper GPU Architecture\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[2402.13499v1](https://arxiv.org/abs/2402.13499v1) \\[[cs.AR](https://arxiv.org/archive/cs.AR)\\].\n65.  **[^](#cite_ref-65 \"Jump up\")** [\"Datasheet NVIDIA A40\"](https://images.nvidia.com/content/Solutions/data-center/a40/nvidia-a40-datasheet.pdf) (PDF). _nvidia.com_. Retrieved 27 April 2024.\n66.  **[^](#cite_ref-66 \"Jump up\")** [\"NVIDIA AMPERE GA102 GPU ARCHITECTURE\"](https://www.nvidia.com/content/PDF/nvidia-ampere-ga-102-gpu-architecture-whitepaper-v2.1.pdf) (PDF). 27 April 2024.\n67.  **[^](#cite_ref-67 \"Jump up\")** [\"Datasheet NVIDIA L40\"](https://www.nvidia.com/content/dam/en-zz/Solutions/design-visualization/support-guide/NVIDIA-L40-Datasheet-January-2023.pdf) (PDF). 27 April 2024.\n68.  **[^](#cite_ref-68 \"Jump up\")** In the Whitepapers the Tensor Core cube diagrams represent the Dot Product Unit Width into the height (4 FP16 for Volta and Turing, 8 FP16 for A100, 4 FP16 for GA102, 16 FP16 for GH100). The other two dimensions represent the number of Dot Product Units (4x4 = 16 for Volta and Turing, 8x4 = 32 for Ampere and Hopper). The resulting gray blocks are the FP16 FMA operations per cycle. Pascal without Tensor core is only shown for speed comparison as is Volta V100 with non-FP16 datatypes.\n69.  **[^](#cite_ref-69 \"Jump up\")** [\"NVIDIA Turing Architecture Whitepaper\"](https://images.nvidia.com/aem-dam/en-zz/Solutions/design-visualization/technologies/turing-architecture/NVIDIA-Turing-Architecture-Whitepaper.pdf) (PDF). _nvidia.com_. Retrieved 5 September 2023.\n70.  **[^](#cite_ref-70 \"Jump up\")** [\"NVIDIA Tensor Core GPU\"](https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/a100/pdf/nvidia-a100-datasheet-us-nvidia-1758950-r4-web.pdf) (PDF). _nvidia.com_. Retrieved 5 September 2023.\n71.  **[^](#cite_ref-71 \"Jump up\")** [\"NVIDIA Hopper Architecture In-Depth\"](https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth/). 22 March 2022.\n72.  **[^](#cite_ref-72 \"Jump up\")** shape x converted operand size, e.g. 2 tensor cores x 4x4x4xFP16/cycle = 256 Bytes/cycle\n73.  **[^](#cite_ref-73 \"Jump up\")** \\= product first 3 table rows\n74.  **[^](#cite_ref-74 \"Jump up\")** \\= product of previous 2 table rows; shape: e.g. 8x8x4xFP16 = 512 Bytes\n75.  **[^](#cite_ref-75 \"Jump up\")** Sun, Wei; Li, Ang; Geng, Tong; Stuijk, Sander; Corporaal, Henk (2023). \"Dissecting Tensor Cores via Microbenchmarks: Latency, Throughput and Numeric Behaviors\". _IEEE Transactions on Parallel and Distributed Systems_. **34** (1): 246–261. [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[2206.02874](https://arxiv.org/abs/2206.02874). [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1109/tpds.2022.3217824](https://doi.org/10.1109%2Ftpds.2022.3217824). [S2CID](https://en.wikipedia.org/wiki/S2CID_\\(identifier\\) \"S2CID (identifier)\") [249431357](https://api.semanticscholar.org/CorpusID:249431357).\n76.  **[^](#cite_ref-76 \"Jump up\")** [\"Parallel Thread Execution ISA Version 7.7\"](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html#warp-level-matrix-instructions-mma).\n77.  **[^](#cite_ref-77 \"Jump up\")** Raihan, Md Aamir; Goli, Negar; Aamodt, Tor (2018). \"Modeling Deep Learning Accelerator Enabled GPUs\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1811.08309](https://arxiv.org/abs/1811.08309) \\[[cs.MS](https://arxiv.org/archive/cs.MS)\\].\n78.  **[^](#cite_ref-78 \"Jump up\")** [\"NVIDIA Ada Lovelace Architecture\"](https://www.nvidia.com/en-gb/geforce/ada-lovelace-architecture).\n79.  **[^](#cite_ref-79 \"Jump up\")** shape x converted operand size, e.g. 2 tensor cores x 4x4x4xFP16/cycle = 256 Bytes/cycle\n80.  **[^](#cite_ref-80 \"Jump up\")** \\= product first 3 table rows\n81.  **[^](#cite_ref-81 \"Jump up\")** \\= product of previous 2 table rows; shape: e.g. 8x8x4xFP16 = 512 Bytes\n82.  **[^](#cite_ref-82 \"Jump up\")** Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1903.07486](https://arxiv.org/abs/1903.07486) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\].\n83.  **[^](#cite_ref-83 \"Jump up\")** Burgess, John (2019). [\"RTX ON – The NVIDIA TURING GPU\"](https://ieeexplore.ieee.org/document/8875651). _2019 IEEE Hot Chips 31 Symposium (HCS)_. pp. 1–27. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1109/HOTCHIPS.2019.8875651](https://doi.org/10.1109%2FHOTCHIPS.2019.8875651). [ISBN](https://en.wikipedia.org/wiki/ISBN_\\(identifier\\) \"ISBN (identifier)\") [978-1-7281-2089-8](https://en.wikipedia.org/wiki/Special:BookSources/978-1-7281-2089-8 \"Special:BookSources/978-1-7281-2089-8\"). [S2CID](https://en.wikipedia.org/wiki/S2CID_\\(identifier\\) \"S2CID (identifier)\") [204822166](https://api.semanticscholar.org/CorpusID:204822166).\n84.  **[^](#cite_ref-84 \"Jump up\")** Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1903.07486](https://arxiv.org/abs/1903.07486) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\].\n85.  **[^](#cite_ref-85 \"Jump up\")** Burgess, John (2019). [\"RTX ON – The NVIDIA TURING GPU\"](https://ieeexplore.ieee.org/document/8875651). _2019 IEEE Hot Chips 31 Symposium (HCS)_. pp. 1–27. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1109/HOTCHIPS.2019.8875651](https://doi.org/10.1109%2FHOTCHIPS.2019.8875651). [ISBN](https://en.wikipedia.org/wiki/ISBN_\\(identifier\\) \"ISBN (identifier)\") [978-1-7281-2089-8](https://en.wikipedia.org/wiki/Special:BookSources/978-1-7281-2089-8 \"Special:BookSources/978-1-7281-2089-8\"). [S2CID](https://en.wikipedia.org/wiki/S2CID_\\(identifier\\) \"S2CID (identifier)\") [204822166](https://api.semanticscholar.org/CorpusID:204822166).\n86.  **[^](#cite_ref-86 \"Jump up\")** dependent on device\n87.  **[^](#cite_ref-87 \"Jump up\")** [\"Tegra X1\"](https://developer.nvidia.com/content/tegra-x1). 9 January 2015.\n88.  **[^](#cite_ref-88 \"Jump up\")** [NVIDIA H100 Tensor Core GPU Architecture](https://nvdam.widen.net/s/5bx55xfnxf/gtc22-whitepaper-hopper)\n89.  **[^](#cite_ref-89 \"Jump up\")** [H.1. Features and Technical Specifications – Table 14. Technical Specifications per Compute Capability](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#features-and-technical-specifications)\n90.  **[^](#cite_ref-90 \"Jump up\")** [NVIDIA Hopper Architecture In-Depth](https://developer.nvidia.com/blog/nvidia-hopper-architecture-in-depth)\n91.  **[^](#cite_ref-91 \"Jump up\")** can only execute 160 integer instructions according to programming guide\n92.  **[^](#cite_ref-92 \"Jump up\")** 128 according to [\\[1\\]](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions). 64 from FP32 + 64 separate units?\n93.  **[^](#cite_ref-93 \"Jump up\")** 64 by FP32 cores and 64 by flexible FP32/INT cores.\n94.  **[^](#cite_ref-94 \"Jump up\")** [\"CUDA C++ Programming Guide\"](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#arithmetic-instructions).\n95.  **[^](#cite_ref-95 \"Jump up\")** 32 FP32 lanes combine to 16 FP64 lanes. Maybe lower depending on model.\n96.  **[^](#cite_ref-96 \"Jump up\")** only supported by 16 FP32 lanes, they combine to 4 FP64 lanes\n97.  ^ [Jump up to: _**a**_](#cite_ref-depending_on_model_97-0) [_**b**_](#cite_ref-depending_on_model_97-1) [_**c**_](#cite_ref-depending_on_model_97-2) [_**d**_](#cite_ref-depending_on_model_97-3) [_**e**_](#cite_ref-depending_on_model_97-4) [_**f**_](#cite_ref-depending_on_model_97-5) depending on model\n98.  **[^](#cite_ref-98 \"Jump up\")** Effective speed, probably over FP32 ports. No description of actual FP64 cores.\n99.  **[^](#cite_ref-99 \"Jump up\")** Can also be used for integer additions and comparisons\n100.  **[^](#cite_ref-100 \"Jump up\")** 2 clock cycles/instruction for each SM partition Burgess, John (2019). [\"RTX ON – The NVIDIA TURING GPU\"](https://ieeexplore.ieee.org/document/8875651). _2019 IEEE Hot Chips 31 Symposium (HCS)_. pp. 1–27. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1109/HOTCHIPS.2019.8875651](https://doi.org/10.1109%2FHOTCHIPS.2019.8875651). [ISBN](https://en.wikipedia.org/wiki/ISBN_\\(identifier\\) \"ISBN (identifier)\") [978-1-7281-2089-8](https://en.wikipedia.org/wiki/Special:BookSources/978-1-7281-2089-8 \"Special:BookSources/978-1-7281-2089-8\"). [S2CID](https://en.wikipedia.org/wiki/S2CID_\\(identifier\\) \"S2CID (identifier)\") [204822166](https://api.semanticscholar.org/CorpusID:204822166).\n101.  **[^](#cite_ref-inside-volta_101-0 \"Jump up\")** Durant, Luke; Giroux, Olivier; Harris, Mark; Stam, Nick (May 10, 2017). [\"Inside Volta: The World's Most Advanced Data Center GPU\"](https://devblogs.nvidia.com/inside-volta/). _Nvidia developer blog_.\n102.  **[^](#cite_ref-102 \"Jump up\")** The schedulers and dispatchers have dedicated execution units unlike with Fermi and Kepler.\n103.  **[^](#cite_ref-103 \"Jump up\")** Dispatching can overlap concurrently, if it takes more than one cycle (when there are less execution units than 32/SM Partition)\n104.  **[^](#cite_ref-104 \"Jump up\")** Can dual issue MAD pipe and SFU pipe\n105.  **[^](#cite_ref-105 \"Jump up\")** No more than one scheduler can issue 2 instructions at once. The first scheduler is in charge of warps with odd IDs. The second scheduler is in charge of warps with even IDs.\n106.  ^ [Jump up to: _**a**_](#cite_ref-shared_memory_only,_no_data_cache_106-0) [_**b**_](#cite_ref-shared_memory_only,_no_data_cache_106-1) shared memory only, no data cache\n107.  ^ [Jump up to: _**a**_](#cite_ref-ReferenceA_107-0) [_**b**_](#cite_ref-ReferenceA_107-1) [_**c**_](#cite_ref-ReferenceA_107-2) [_**d**_](#cite_ref-ReferenceA_107-3) [_**e**_](#cite_ref-ReferenceA_107-4) [_**f**_](#cite_ref-ReferenceA_107-5) shared memory separate, but L1 includes texture cache\n108.  **[^](#cite_ref-108 \"Jump up\")** [\"H.6.1. Architecture\"](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#architecture-7-x). _docs.nvidia.com_. Retrieved 2019-05-13.\n109.  **[^](#cite_ref-109 \"Jump up\")** [\"Demystifying GPU Microarchitecture through Microbenchmarking\"](https://www.stuffedcow.net/files/gpuarch-ispass2010.pdf) (PDF).\n110.  **[^](#cite_ref-110 \"Jump up\")** Jia, Zhe; Maggioni, Marco; Staiger, Benjamin; Scarpazza, Daniele P. (2018). \"Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1804.06826](https://arxiv.org/abs/1804.06826) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\].\n111.  **[^](#cite_ref-111 \"Jump up\")** [\"Tegra X1\"](https://developer.nvidia.com/content/tegra-x1). 9 January 2015.\n112.  **[^](#cite_ref-112 \"Jump up\")** Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1903.07486](https://arxiv.org/abs/1903.07486) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\].\n113.  **[^](#cite_ref-113 \"Jump up\")** [\"Dissecting the Ampere GPU Architecture through Microbenchmarking\"](https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s33322/).\n114.  **[^](#cite_ref-114 \"Jump up\")** Note that Jia, Zhe; Maggioni, Marco; Smith, Jeffrey; Daniele Paolo Scarpazza (2019). \"Dissecting the NVidia Turing T4 GPU via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1903.07486](https://arxiv.org/abs/1903.07486) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\]. disagrees and states 2 KiB L0 instruction cache per SM partition and 16 KiB L1 instruction cache per SM\n115.  **[^](#cite_ref-115 \"Jump up\")** Jia, Zhe; Maggioni, Marco; Staiger, Benjamin; Scarpazza, Daniele P. (2018). \"Dissecting the NVIDIA Volta GPU Architecture via Microbenchmarking\". [arXiv](https://en.wikipedia.org/wiki/ArXiv_\\(identifier\\) \"ArXiv (identifier)\"):[1804.06826](https://arxiv.org/abs/1804.06826) \\[[cs.DC](https://arxiv.org/archive/cs.DC)\\].\n116.  **[^](#cite_ref-116 \"Jump up\")** [\"asfermi Opcode\"](https://github.com/hyqneuron/asfermi/wiki/Opcode). _[GitHub](https://en.wikipedia.org/wiki/GitHub \"GitHub\")_.\n117.  ^ [Jump up to: _**a**_](#cite_ref-ReferenceB_117-0) [_**b**_](#cite_ref-ReferenceB_117-1) for access with texture engine only\n118.  **[^](#cite_ref-118 \"Jump up\")** 25% disabled on RTX 4090\n119.  **[^](#cite_ref-119 \"Jump up\")** [\"I.7. Compute Capability 8.x\"](https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capability-8-x). _docs.nvidia.com_. Retrieved 2022-10-12.\n120.  **[^](#cite_ref-120 \"Jump up\")** [\"Appendix F. Features and Technical Specifications\"](http://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/CUDA_C_Programming_Guide.pdf) (PDF). (3.2 MiB), page 148 of 175 (Version 5.0 October 2012).\n121.  **[^](#cite_ref-121 \"Jump up\")** [\"nVidia CUDA Bioinformatics: BarraCUDA\"](https://www.biocentric.nl/biocentric/nvidia-cuda-bioinformatics-barracuda/). _BioCentric_. 2019-07-19. Retrieved 2019-10-15.\n122.  **[^](#cite_ref-122 \"Jump up\")** [\"Part V: Physics Simulation\"](https://developer.nvidia.com/gpugems/gpugems3/part-v-physics-simulation). _NVIDIA Developer_. Retrieved 2020-09-11.\n123.  **[^](#cite_ref-123 \"Jump up\")** [\"oneAPI Programming Model\"](https://www.oneapi.io/). _oneAPI.io_. Retrieved 2024-07-27.\n124.  **[^](#cite_ref-124 \"Jump up\")** [\"Specifications | oneAPI\"](https://www.oneapi.io/spec/). _oneAPI.io_. Retrieved 2024-07-27.\n125.  **[^](#cite_ref-125 \"Jump up\")** [\"oneAPI Specification — oneAPI Specification 1.3-rev-1 documentation\"](https://oneapi-spec.uxlfoundation.org/specifications/oneapi/v1.3-rev-1/). _oneapi-spec.uxlfoundation.org_. Retrieved 2024-07-27.\n126.  **[^](#cite_ref-126 \"Jump up\")** [\"Exclusive: Behind the plot to break Nvidia's grip on AI by targeting software\"](https://www.reuters.com/technology/behind-plot-break-nvidias-grip-ai-by-targeting-software-2024-03-25/). _[Reuters](https://en.wikipedia.org/wiki/Reuters \"Reuters\")_. Retrieved 2024-04-05.\n127.  **[^](#cite_ref-127 \"Jump up\")** [\"Question: What does ROCm stand for? · Issue #1628 · RadeonOpenCompute/ROCm\"](https://github.com/RadeonOpenCompute/ROCm/issues/1628). _Github.com_. Retrieved January 18, 2022.\n\n*   Buck, Ian; Foley, Tim; Horn, Daniel; Sugerman, Jeremy; Fatahalian, Kayvon; Houston, Mike; Hanrahan, Pat (2004-08-01). [\"Brook for GPUs: stream computing on graphics hardware\"](https://dl.acm.org/doi/10.1145/1015706.1015800). _ACM Transactions on Graphics_. **23** (3): 777–786. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1145/1015706.1015800](https://doi.org/10.1145%2F1015706.1015800). [ISSN](https://en.wikipedia.org/wiki/ISSN_\\(identifier\\) \"ISSN (identifier)\") [0730-0301](https://search.worldcat.org/issn/0730-0301).\n*   Nickolls, John; Buck, Ian; Garland, Michael; Skadron, Kevin (2008-03-01). [\"Scalable Parallel Programming with CUDA: Is CUDA the parallel programming model that application developers have been waiting for?\"](https://dl.acm.org/doi/10.1145/1365490.1365500). _Queue_. **6** (2): 40–53. [doi](https://en.wikipedia.org/wiki/Doi_\\(identifier\\) \"Doi (identifier)\"):[10.1145/1365490.1365500](https://doi.org/10.1145%2F1365490.1365500). [ISSN](https://en.wikipedia.org/wiki/ISSN_\\(identifier\\) \"ISSN (identifier)\") [1542-7730](https://search.worldcat.org/issn/1542-7730).\n\n*   [Official website](https://developer.nvidia.com/cuda-zone) [![Edit this at Wikidata](https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png)](https://www.wikidata.org/wiki/Q477690#P856 \"Edit this at Wikidata\")",
        "debug": {
            "requestHandlerMode": "browser"
        }
    }
]